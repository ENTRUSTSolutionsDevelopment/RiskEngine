# -*- coding: utf-8 -*-####################################################################################################################### Copyright Â© 2025 Entrust Solutions Group.# All Rights Reserved.# Threat Risk:#       Corrosion# Variable Type:#       Exposure# Variable:#       Soil Corrosivity# Variable Description:#       External Corrosion influencing factors#       pH, Moisture, Temperature are all factors influencing this exposure.#       We are using the SSURGO national soil survey data to approximate a corrosivity value.#       SSURGO soil corrosivity lookup table:#           {'low':1,#           'moderate':5,#           'high':16}# Units:#       mpy# Source(s):#       Distribution Mains#           URL: https://ene.maps.arcgis.com/home/item.html?id=cd0407318f46497ea53201ed9b19a884#       SSURGO soil corrosivity map#             URL: https://landscape11.arcgis.com/arcgis/services/USA_Soils_Corrosion_Steel/ImageServer# Field Name(s):#       N/A# Tier 1 Determination Method:#       For metallic pipe, where corrosion measurements are available,#       apply an estimated mpy value to pipe within 10 feet of the corrosion measurement#       estimated mpy is equal to measure wall loss (mils) / time of exposure (years).#       Time of exposure can be approximated to be date of observation - date of installation.# Tier 1 Determination Method Source(s):#       Distribution_main, corrosion measurements# Tier 2 Determination Method:#       for metallic pipe, if soil_corrosivity is not None, return mpy value from soil corrosivity lookup table:#           {'low':1,#           'moderate':5,#            'high':16}# Tier 2 Determination Method Source(s):#       SSURGO https://ene.maps.arcgis.com/home/item.html?id=99386adc2f964505a069622ba24f7265# Tier 3 Determination Method:#      if measured_soil_corrosivity is None and soil_corrosivity is None, return 16 mpy# Tier 3 Determination Method Source(s):#       N/A########################################################################################################################import arcpyimport numpy as npimport osimport uuid# online distribution mains feature class name,# this feature class will be created in the output GDB if it does not existDIST_MAINS_FC_NAME = "DistMains_Routes"# New fields to addSoil_Corrosion_fld = "Soil_Corrosion"DIST_MAINS_FIELD_DESCRIPTION = [[Soil_Corrosion_fld, "Double", Soil_Corrosion_fld, None]]class Toolbox:    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [E_SoilCorrosivity]class E_SoilCorrosivity:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "E_SoilCorrosivity"        self.description = "E_SoilCorrosivity"    def getParameterInfo(self):        """Define the tool parameters."""        params = []        # param 0        in_dist_mains = arcpy.Parameter(            displayName="Input Distribution Mains Features", name="in_dist_mains",            datatype="GPFeatureLayer", parameterType="Required",            direction="Input")         # param 1        route_id_fld = arcpy.Parameter(            displayName="Input Route ID Field",            name="route_id_fld",            datatype="Field",            parameterType="Required",            direction="Input")        route_id_fld.parameterDependencies = [in_dist_mains.name]        # param 2        material_fld = arcpy.Parameter(            displayName="Input Material Type Field",            name="material_fld",            datatype="Field",            parameterType="Required",            direction="Input")        material_fld.parameterDependencies = [in_dist_mains.name]        # param 3        plastic_material_val = arcpy.Parameter(            displayName="Input Plastic Material Type Value",            name="plastic_material_val",            datatype="GPLong",            parameterType="Required",            direction="Input")        # param 4        in_soil_corr = arcpy.Parameter(            displayName="Input USA SSURGO Soil Corrosion Layer", name="in_soil_corr",            datatype= "GPString", #  ["DEMapServer", "GPMapServerLayer", "GPRasterLayer", "GPFeatureLayer"],#             datatype= ["GPMapServerLayer", "GPRasterLayer", "GPFeatureLayer" ],            parameterType="Required",            direction="Input")#         # param 5#         raster_clip_extent = arcpy.Parameter(#                     displayName="Clipping Extent",#                     name="raster_clip_extent",#                     datatype="GPExtent",#                     parameterType="Optional",#                     direction="Input")        # param 5        out_gdb = arcpy.Parameter(            displayName="Output GDB",            name="out_gdb",            datatype="GPString",            parameterType="Optional",            direction="Input")#         out_gdb.value = r"C:\temp\RiskEngine.gdb"        # param 6        out_soil_corr_table = arcpy.Parameter(            displayName="Output Soil Corrosivity Table",            name="out_soil_corr_table",            datatype="GPString",            parameterType="Optional",            direction="Input")#         out_soil_corr_table.value = "E_SoilCorrosivity"        # param 7        gp_messages = arcpy.Parameter(            displayName="Geoprocessing Messages",            name="gp_messages",            datatype="GPString",            parameterType="Optional",            direction="Output")        # param 8        status = arcpy.Parameter(            displayName="Tool Status",            name="status",            datatype="GPString",            parameterType="Optional",            direction="Output")         # param 9        output_table = arcpy.Parameter(            displayName="Output Linear Events Table",            name="output_table",            datatype="GPTableView",            parameterType="Optional",            direction="Output")        # param 10        portal_ulr = arcpy.Parameter(            displayName="ArcGIS Portal URL",            name="portal_ulr",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 11        portal_username = arcpy.Parameter(            displayName="ArcGIS Portal User Name",            name="portal_username",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 12        portal_password = arcpy.Parameter(            displayName="ArcGIS Portal Password",            name="portal_password",            datatype="GPStringHidden",            parameterType="Optional",            direction="Input")        params = [in_dist_mains, route_id_fld, material_fld, plastic_material_val,                    in_soil_corr,#                     raster_clip_extent,                    out_gdb, out_soil_corr_table, gp_messages, status,                    output_table, portal_ulr, portal_username, portal_password]        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""#         extent_feature_layer = parameters[0].value#         if extent_feature_layer:#             try:#                 desc = arcpy.Describe(extent_feature_layer)#                 extent_obj = desc.extent#                 extent_string = f"{extent_obj.XMin} {extent_obj.YMin} {extent_obj.XMax} {extent_obj.YMax}"#                 parameters[5].value = extent_string#             except:#                 parameters[5].value = None#                 arcpy.AddWarning("Could not get extent from the selected feature layer.")##         if not parameters[7]:#             parameters[7].value =  "E_SoilCorrosivity"        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    def signin_portal(self, portal_url, username, password):        """            Login to the ArcGIS Portal to access input data sources            portal_url: ArcGIS Portal URL            username: User name            password: Password        """        if arcpy.GetSigninToken() is None:            try:                if username is not None and  password is not None:                    arcpy.SignInToPortal(portal_url, username, password)                else:                    arcpy.SignInToPortal(portal_url)                arcpy.AddMessage("ArcGIS Portal Login Successful.")            except Exception as e:                arcpy.AddError("ArcGIS Portal Login Failed!."                                "\n{}".format(arcpy.GetMessages(2)))                raise    def preprocess_distmains(self, infc, gdb, dist_mains_routes, unique_fld):        """            Creates online distribution mains features from input distribution mains features            infc: Input distribution mains features            gdb: Path of the geodatabase to save output online distribution mains features            dist_mains_routes: Name of the output online distribution mains feature class            unique_fld: Name of the GUID column to be added to output online distribution mains feature class        """        try:            dist_mains = os.path.join(gdb, "DistMains")            arcpy.AddMessage("Copy Features Dist Mains From Portal...")            from_meas_fld = "FROM_MEASURE"            to_meas_fld = "TO_MEASURE"            arcpy.management.CopyFeatures(in_features=infc,                                          out_feature_class=dist_mains,                                          config_keyword="",                                          spatial_grid_1=None,                                          spatial_grid_2=None,                                          spatial_grid_3=None)            field_list = arcpy.ListFields(dist_mains, from_meas_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{from_meas_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(dist_mains, from_meas_fld, "Double")                arcpy.AddMessage(f"Field '{from_meas_fld}' added successfully.")            arcpy.AddMessage("Calculate Geometry Attributes...")            arcpy.management.CalculateGeometryAttributes(in_features=dist_mains,                                                         geometry_property=to_meas_fld + " LENGTH_GEODESIC",                                                         length_unit="FEET_US",                                                         area_unit="",                                                         coordinate_system=None,                                                         coordinate_format="SAME_AS_INPUT")            field_list = arcpy.ListFields(dist_mains, unique_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{unique_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(dist_mains, unique_fld, "GUID")                arcpy.AddMessage(f"Field '{unique_fld}' added successfully.")            # Create an update cursor to calculate GUID values            with arcpy.da.UpdateCursor(dist_mains, [from_meas_fld, unique_fld]) as cursor:                for row in cursor:                    row[0] = 0                    # Generate a new GUID value                    guid_value = str(uuid.uuid4())                    # Update the row with the new GUID                    row[1] = guid_value                    cursor.updateRow(row)            arcpy.AddMessage(f"GUID values calculated and populated in the '{unique_fld}' field.")            arcpy.AddMessage("Creating route features...")            # create routes            arcpy.lr.CreateRoutes(                in_line_features=dist_mains,                route_id_field=unique_fld,                out_feature_class=dist_mains_routes,                measure_source="TWO_FIELDS",                from_measure_field=from_meas_fld,                to_measure_field=to_meas_fld,                coordinate_priority="UPPER_LEFT",                measure_factor=1,                measure_offset=0,                ignore_gaps="IGNORE",                build_index="INDEX"            )            arcpy.AddMessage("Join Field...")            arcpy.management.JoinField(                in_data=dist_mains_routes,                in_field=unique_fld,                join_table=dist_mains,                join_field=unique_fld,                fields=None,                fm_option="NOT_USE_FM",                field_mapping=None,                index_join_fields="NO_INDEXES"            )            field_list = arcpy.ListFields(dist_mains_routes, unique_fld+"_1")            if len(field_list) > 0:                arcpy.AddMessage("Delete Field...")                arcpy.management.DeleteField(dist_mains_routes,[unique_fld+"_1"])        except Exception as e:            raise    def add_message(self, parameters, msg, gp_msg_no, status_no):        try:            parameters[gp_msg_no].value = parameters[gp_msg_no].valueAsText + "\n " + msg            arcpy.AddMessage(msg)        except Exception as e:            parameters[gp_msg_no].value = parameters[gp_msg_no].valueAsText + "\n " + str(e)            parameters[status_no].value = "Error"            raise    def execute(self, parameters, messages):        """The source code of the tool."""        arcpy.env.overwriteOutput = True        dist_mains = parameters[0].value        route_id_fld = parameters[1].valueAsText        material_fld = parameters[2].valueAsText        plastic_material_val = int(parameters[3].value)        in_soil_corr = parameters[4].value#             raster_clip_extent =  parameters[5].value#             parameters[5].value = parameters[0].value        out_gdb_name = parameters[5].valueAsText        output_table_name = parameters[6].valueAsText        soil_corr_table = os.path.join(out_gdb_name, output_table_name)        linear_events_table = os.path.join(out_gdb_name, output_table_name + "Table")#             parameters[7].value = "Starting..."#             parameters[8].value = ""        gp_msg_no = 7        status_no = 8        parameters[9].value = os.path.join(out_gdb_name, out_excav_damage_table)        portal_ulr = parameters[10].value        portal_username = parameters[11].value        portal_password = parameters[12].value        parameters[gp_msg_no].value = "Starting..."        parameters[status_no].value = ""        try:            soil_raster_clip =  os.path.join(out_gdb_name, "E_SC_Soil_Raster_Clip1")            soil_raster2poly =  os.path.join(out_gdb_name, "E_SC_Soil_Raster2Poly1")            temp_buffer =  os.path.join(out_gdb_name, "E_Temp_Buffer")            mains_soil_corr_intersect =  os.path.join(out_gdb_name, "E_SC_Mains_SoilCorr_Intersect1")            mains_soil_corr_erase =  os.path.join(out_gdb_name, "E_SC_Mains_SoilCorr_Erase1")            cp_Temp =  os.path.join(out_gdb_name, "E_SC_Mains_NonPlastic1")             # sign in to portal            self.signin_portal(portal_ulr, portal_username, portal_password)            # check in dist mains exist in the file geodatabase            self.add_message(parameters, "Checking Input Dist Mains...", gp_msg_no, status_no)            if not arcpy.Exists(dist_mains_routes):    #             # sign in to portal    #             self.signin_portal(portal_ulr, portal_username, portal_password)                self.preprocess_distmains(dist_mains, out_gdb_name, dist_mains_routes, route_id_fld)            # select non plastic distribution main            self.add_message(parameters, "Select Layer By Attribute NonPlastic Mains...", gp_msg_no, status_no)            whereclause = f"{material_fld} NOT IN ({plastic_material_val})" # f"{material_fld} <> {plastic_material_val}"            dist_plastic = arcpy.management.SelectLayerByAttribute(in_layer_or_view=dist_mains_routes,                                    selection_type="NEW_SELECTION",                                    where_clause=whereclause,                                    invert_where_clause=None)            self.add_message(parameters, "Copy Features NonPlastic Mains...", gp_msg_no, status_no)            arcpy.management.CopyFeatures(in_features=dist_plastic[0],                                            out_feature_class=cp_Temp,                                            config_keyword="",                                            spatial_grid_1=None,                                            spatial_grid_2=None,                                            spatial_grid_3=None)            self.add_message(parameters, "Add Fields NonPlastic Mains...", gp_msg_no, status_no)            arcpy.management.AddFields(cp_Temp, DIST_MAINS_FIELD_DESCRIPTION)            # get mains extent            desc = arcpy.Describe(cp_Temp)            xmin = desc.extent.XMin            xmax = desc.extent.XMax            ymin = desc.extent.YMin            ymax = desc.extent.YMax            rect = f"{xmin} {ymin} {xmax} {ymax}"            self.add_message(parameters, "Clip Raster...", gp_msg_no, status_no)#             with arcpy.EnvManager(extent=desc.extent):            arcpy.management.Clip(in_raster=in_soil_corr,                        rectangle=rect,                        out_raster=soil_raster_clip,                        in_template_dataset="",                        nodata_value="0",                        clipping_geometry="NONE",                        maintain_clipping_extent="NO_MAINTAIN_EXTENT")            self.add_message(parameters, "Raster To Polygon...", gp_msg_no, status_no)            arcpy.conversion.RasterToPolygon(in_raster=soil_raster_clip,                                    out_polygon_features=soil_raster2poly,                                    simplify="SIMPLIFY",                                    raster_field="Value",                                    create_multipart_features="SINGLE_OUTER_PART",                                    max_vertices_per_feature=None)            self.add_message(parameters, "Pairwise Intersect Mains...", gp_msg_no, status_no)            inlayers = [cp_Temp, soil_raster2poly]            arcpy.analysis.PairwiseIntersect(in_features=inlayers,                                                out_feature_class=mains_soil_corr_intersect,                                                join_attributes="ALL",                                                cluster_tolerance=None,                                                output_type="LINE")            self.add_message(parameters, "Pairwise Erase Mains...", gp_msg_no, status_no)            arcpy.analysis.PairwiseErase(in_features=dist_mains_routes,                                                erase_features=mains_soil_corr_intersect,                                                out_feature_class=mains_soil_corr_erase,                                                cluster_tolerance=None)            self.add_message(parameters, "Merge Mains...", gp_msg_no, status_no)            in_features = [mains_soil_corr_erase, mains_soil_corr_intersect]            arcpy.management.Merge(inputs=in_features,                                    output=soil_corr_table,                                    add_source="NO_SOURCE_INFO")            self.add_message(parameters, "Add Field Soil Corrosion Mains...", gp_msg_no, status_no)            arcpy.management.AddFields(soil_corr_table, DIST_MAINS_FIELD_DESCRIPTION)            self.add_message(parameters, "Calculating Soil_Corrosion...", gp_msg_no, status_no)            fields =["gridcode",Soil_Corrosion_fld]            with arcpy.da.UpdateCursor(soil_corr_table, fields) as cursor:                for row in cursor:                    gridcode = row[0]                    if gridcode:                        try:                            if gridcode == 1:                                row[1] = 1                            elif gridcode == 2:                                row[1] = 5                            elif gridcode == 3:                                row[1] = 16                        except Exception as e:                            parameters[7].value = "Error"                            raise                    else:                        row[1] = 16                    cursor.updateRow(row)            self.add_message(parameters, "Creating output linear events table...", gp_msg_no, status_no)            arcpy.lr.LocateFeaturesAlongRoutes(in_features=soil_corr_table,                                            in_routes=dist_mains_routes,                                            route_id_field=route_id_fld,                                            radius_or_tolerance="0 Meters",                                            out_table=linear_events_table,                                            out_event_properties= route_id_fld + "; LINE; FROM_MEASURE; TO_MEASURE",                                            route_locations="FIRST",                                            distance_field="DISTANCE",                                            zero_length_events="ZERO",                                            in_fields="FIELDS",                                            m_direction_offsetting="M_DIRECTON")            parameters[status_no].value = "Success"            self.add_message(parameters, "Finished!", gp_msg_no, status_no)        except Exception as e:            parameters[status_no].value = "Error"            self.add_message(parameters, str(e), gp_msg_no, status_no)            raise        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return