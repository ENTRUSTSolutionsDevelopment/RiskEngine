# -*- coding: utf-8 -*-####################################################################################################################### Copyright Â© 2025 Entrust Solutions Group.# All Rights Reserved.# Threat Risk:#       Corrosion# Variable Type:#       Mitigation# Variable:#       Cathodic Protection# Variable Description:#       Uses CP read data to identify areas of low reads that may be more susceptible to corrosion#       Pipe cathodically protected#       Need to consider also CP that's too high because that can damage coating#       do we need to consider time CP is down (impressed vs. anodic / inspection frequency)#       considerations for both impressed and anodic#       (if working, should be same level of protection but mitigation is different)#       CP is adequate for the entire CP system if PY Annual Read less negative that -0.850 mV#       Shorted casing consideration:#       ABS(PY Structure Read - PY Casing Read)#       if ABS of difference is <= 0.100, shorted#       if ABS > 0.100, not shorted#       if a casing is shorted, the mitigation from CP is negated on the shorted pipe within 100 feet of either side of the casing.# Units:#       %# Source(s):#       Distribution Mains#           URL: https://ene.maps.arcgis.com/home/item.html?id=cd0407318f46497ea53201ed9b19a884#       Audit Reads#             URL: https://services1.arcgis.com/Ebe2vzeJnfgD83DH/arcgis/rest/services/Casing_FOR_DEVELOPMENT_MergedReads/FeatureServer/0#       Casings#             https://services1.arcgis.com/Ebe2vzeJnfgD83DH/arcgis/rest/services/Casing_FOR_DEVELOPMENT/FeatureServer/0# Field Name(s):#       N/A# Tier 1 Determination Method:#       if metallic pipe, and if CP reads indicate that CP is adequate: CP mitigation is 94%.#       if CP reads indicate that CP is inadequate: CP mitigation is 0%.#       If is_shorted, CP mitigation is 0%, else: no change.# Tier 1 Determination Method Source(s):#       Distribution_Main, annual_reads#       Casings2024#       RGE Regulatory Audit Reads#       NYSEG Regulatory Audit Reads# Tier 2 Determination Method:#       if metallic pipe, and if segment part of CP system:  CP mitigation is either 94%.#       If is_shorted, CP mitigation is 0%, else: no change.# Tier 2 Determination Method Source(s):#       Distribution_Main, annual_reads#       Casings2024#       RGE Regulatory Audit Reads#       NYSEG Regulatory Audit Reads# Tier 3 Determination Method:#      SME input survey value: Cathodic Protection Effectiveness#       If is_shorted, CP mitigation is 0%, else: no change.# Tier 3 Determination Method Source(s):#       SME input survey value: Cathodic Protection Effectiveness########################################################################################################################import arcpyimport numpy as npimport osimport uuid# online distribution mains feature class name,# this feature class will be created in the output GDB if it does not existDIST_MAINS_FC_NAME = "DistMains_Routes"# New fields to addCP_Presence_fld = "CP_Presence"reads_id_fld = "AUDITREADS_UNIQUE_ID"annual_read_fld = "Annual_Read"casing_read_fld = "Casing_Read"CP_Mitigation_fld = "CP_Mitigation"casings_id_fld = "CASINGS_UNIQUE_ID"DIST_MAINS_FIELD_DESCRIPTION = [[CP_Presence_fld, "TEXT", CP_Presence_fld, 3],                                            [reads_id_fld, "TEXT", reads_id_fld, 50],                                            [annual_read_fld, "Double", annual_read_fld, None],                                            [casing_read_fld, "Double", casing_read_fld, None],                                            [CP_Mitigation_fld, "Double", CP_Mitigation_fld, None],                                            [casings_id_fld, "TEXT", casings_id_fld, 50],                                            ]class Toolbox:    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [M_CathodicProtection]class M_CathodicProtection:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "M_CathodicProtection"        self.description = ""    def getParameterInfo(self):        """Define the tool parameters."""        params = []        # param 0        in_dist_mains = arcpy.Parameter(            displayName="Input Distribution Mains Features", name="in_dist_mains",            datatype="GPFeatureLayer", parameterType="Required",            direction="Input")        # param 1        material_fld = arcpy.Parameter(            displayName="Input Material Type Field",            name="material_fld",            datatype="Field",            parameterType="Required",            direction="Input")        material_fld.parameterDependencies = [in_dist_mains.name]         # param 2        plastic_material_val = arcpy.Parameter(            displayName="Input Plastic Material Type Value",            name="plastic_material_val",            datatype="GPLong",            parameterType="Required",            direction="Input")        # param 3        cp_section_fld = arcpy.Parameter(            displayName="Input CP Section Field",            name="cp_section_fld",            datatype="Field",            parameterType="Required",            direction="Input")        cp_section_fld.parameterDependencies = [in_dist_mains.name]#         # param 4#         cpsytem_fld = arcpy.Parameter(#             displayName="Input CP System Field",#             name="cpsytem_fld",#             datatype="Field",#             parameterType="Required",#             direction="Input")#         cpsytem_fld.parameterDependencies = [in_dist_mains.name]        # param 4        route_id_fld = arcpy.Parameter(            displayName="Input Dist Mains Unique ID Field Name",            name="route_id_fld",            datatype="GPString",            parameterType="Required",            direction="Input")#         route_id_fld.parameterDependencies = [in_dist_mains.name]        # param 5        in_audit_reads = arcpy.Parameter(            displayName="Input Audit Reads Features", name="in_audit_reads",            datatype=["GPTableView", "GPFeatureLayer"], parameterType="Required",            direction="Input")#          # param 7#         reads_uniquid_id_fld = arcpy.Parameter(#             displayName="Input Audit Reads Unique ID Field",#             name="reads_uniquid_id_fld",#             datatype="Field",#             parameterType="Required",#             direction="Input")#         reads_uniquid_id_fld.parameterDependencies = [in_audit_reads.name]        # param 6        py_annual_read_fld = arcpy.Parameter(            displayName="Input Annual Read Field",            name="py_annual_read_fld",            datatype="Field",            parameterType="Required",            direction="Input")        py_annual_read_fld.parameterDependencies = [in_audit_reads.name]        # param 7        py_casing_read_fld = arcpy.Parameter(            displayName="Input Casing Read Field",            name="py_casing_read_fld",            datatype="Field",            parameterType="Required",            direction="Input")        py_casing_read_fld.parameterDependencies = [in_audit_reads.name]#         # param 10#         dist_trans_fld = arcpy.Parameter(#             displayName="Input Transmission Type Field",#             name="dist_trans_fld",#             datatype="Field",#             parameterType="Required",#             direction="Input")#         dist_trans_fld.parameterDependencies = [in_audit_reads.name]        # param 8        section_fld = arcpy.Parameter(            displayName="Input CP Section Field",            name="section_fld",            datatype="Field",            parameterType="Required",            direction="Input")        section_fld.parameterDependencies = [in_audit_reads.name]        # param 9        anuual_read_value = arcpy.Parameter(            displayName="Input Adequate Annual Read Value",            name="anuual_read_value",            datatype="GPDouble",            parameterType="Required",            direction="Input")#         anuual_read_value.value = -0.85        # param 10        shorted_read_value = arcpy.Parameter(            displayName="Input Shorted Read Value",            name="shorted_read_value",            datatype="GPDouble",            parameterType="Required",            direction="Input")#         shorted_read_value.value = 0.1        # param 11        reads_uniquid_id_fld = arcpy.Parameter(            displayName="Input Audit Reads Unique ID Field Name",            name="reads_uniquid_id_fld",            datatype="GPString",            parameterType="Required",            direction="Input")        # param 12        in_casings = arcpy.Parameter(            displayName="Input Casings Features", name="in_casings",            datatype="GPFeatureLayer", parameterType="Required",            direction="Input")         # param 13        is_shorted_fld = arcpy.Parameter(            displayName="Input Casings Is Shorted Field",            name="is_shorted_fld",            datatype="Field",            parameterType="Required",            direction="Input")        is_shorted_fld.parameterDependencies = [in_casings.name]        # param 14        casings_uniquid_id_fld = arcpy.Parameter(            displayName="Input Casings Unique ID Field Name",            name="casings_uniquid_id_fld",            datatype="GPString",            parameterType="Required",            direction="Input")#         casings_uniquid_id_fld.parameterDependencies = [in_casings.name]        # param 15        out_gdb = arcpy.Parameter(            displayName="Output GDB Name",            name="out_gdb",            datatype="GPString",            parameterType="Optional",            direction="Input")#         out_gdb.value = r"C:\temp\RiskEngine.gdb"        # param 16        out_cathodic_prot_table = arcpy.Parameter(            displayName="Output AC Interference Corrosion Table",            name="out_cathodic_prot_table",            datatype="GPString",            parameterType="Optional",            direction="Input")        out_cathodic_prot_table.value = "M_CathodicProtection"        # param 17        gp_messages = arcpy.Parameter(            displayName="Geoprocessing Messages",            name="gp_messages",            datatype="GPString",            parameterType="Optional",            direction="Output")        # param 18        status = arcpy.Parameter(            displayName="Tool Status",            name="status",            datatype="GPString",            parameterType="Optional",            direction="Output")        # param 19        output_table = arcpy.Parameter(            displayName="Output Linear Events Table",            name="output_table",            datatype="GPTableView",            parameterType="Optional",            direction="Output")        # param 20        portal_ulr = arcpy.Parameter(            displayName="ArcGIS Portal URL",            name="portal_ulr",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 21        portal_username = arcpy.Parameter(            displayName="ArcGIS Portal User Name",            name="portal_username",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 22        portal_password = arcpy.Parameter(            displayName="ArcGIS Portal Password",            name="portal_password",            datatype="GPStringHidden",            parameterType="Optional",            direction="Input")        params = [in_dist_mains, material_fld, plastic_material_val, cp_section_fld, #cpsytem_fld,                    route_id_fld,                 in_audit_reads,  py_annual_read_fld, py_casing_read_fld,  section_fld, # dist_trans_fld,                 anuual_read_value, shorted_read_value, reads_uniquid_id_fld,                 in_casings, is_shorted_fld, casings_uniquid_id_fld,                 out_gdb, out_cathodic_prot_table, gp_messages, status, output_table,                 portal_ulr, portal_username, portal_password]        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""                 return    def trace_lines_connected_to_point(self, polyline_feature_class, point_feature_class, output_feature_class):        """        Traces connected polyline features starting from any line that has an        endpoint coincident with any point in the specified point feature class.        It traces connected lines on both ends until no more connected lines are found.        Args:            polyline_feature_class (str): Path to the input polyline feature class.            point_feature_class (str): Path to the input point feature class.            output_feature_class (str): Path to the output feature class that will                                         contain the traced connected lines.        """        try:            # Create feature layers            arcpy.MakeFeatureLayer_management(polyline_feature_class, "polyline_lyr")            arcpy.MakeFeatureLayer_management(point_feature_class, "point_lyr")            connected_lines_oids = set()            initial_connected_oids = set()            # Find initial lines connected to the points            with arcpy.da.SearchCursor("point_lyr", ["SHAPE@"]) as point_cursor:                for point_row in point_cursor:                    point_geometry = point_row[0]                    with arcpy.da.SearchCursor("polyline_lyr", ["OID@", "SHAPE@"]) as polyline_cursor:                        for polyline_oid, polyline_geometry in polyline_cursor:                            if polyline_geometry.firstPoint.equals(point_geometry) or \                               polyline_geometry.lastPoint.equals(point_geometry):                                initial_connected_oids.add(polyline_oid)            if not initial_connected_oids:                print("No lines found directly connected to the specified points.")                return            processed_oids = set()            lines_to_process = list(initial_connected_oids)            connected_lines_oids.update(initial_connected_oids)            while lines_to_process:                current_oid = lines_to_process.pop(0)                processed_oids.add(current_oid)                # Get the geometry of the current line                with arcpy.da.SearchCursor("polyline_lyr", ["SHAPE@"], f"OBJECTID = {current_oid}") as cursor:                    for row in cursor:                        current_polyline = row[0]                        break                    else:                        continue  # Skip if the current line's geometry cannot be retrieved                # Iterate through all other polylines to find connections                with arcpy.da.SearchCursor("polyline_lyr", ["OID@", "SHAPE@"]) as cursor:                    for other_oid, other_polyline in cursor:                        if other_oid not in processed_oids:                            if current_polyline.touches(other_polyline):                                if other_oid not in connected_lines_oids:                                    connected_lines_oids.add(other_oid)                                    lines_to_process.append(other_oid)            # Create a where clause to select the traced lines            where_clause = f"OBJECTID IN ({','.join(map(str, connected_lines_oids))})"            # Select the connected lines            arcpy.SelectLayerByAttribute_management("polyline_lyr", "NEW_SELECTION", where_clause)            # Copy the selected features to the output feature class            arcpy.CopyFeatures_management("polyline_lyr", output_feature_class)            # Clean up temporary layers            arcpy.Delete_management("polyline_lyr")            arcpy.Delete_management("point_lyr")            print(f"Successfully traced connected lines from the points and saved them to: {output_feature_class}")        except arcpy.ExecuteError:            print(arcpy.GetMessages(2))        except Exception as e:            print(f"An error occurred: {e}")    def signin_portal(self, portal_url, username, password):        """            Login to the ArcGIS Portal to access input data sources            portal_url: ArcGIS Portal URL            username: User name            password: Password        """        if arcpy.GetSigninToken() is None:            try:                if username is not None and  password is not None:                    arcpy.SignInToPortal(portal_url, username, password)                else:                    arcpy.SignInToPortal(portal_url)                arcpy.AddMessage("ArcGIS Portal Login Successful.")            except Exception as e:                arcpy.AddError("ArcGIS Portal Login Failed!."                                "\n{}".format(arcpy.GetMessages(2)))                raise    def preprocess_distmains(self, infc, gdb, dist_mains_routes, unique_fld):        """            Creates online distribution mains features from input distribution mains features            infc: Input distribution mains features            gdb: Path of the geodatabase to save output online distribution mains features            dist_mains_routes: Name of the output online distribution mains feature class            unique_fld: Name of the GUID column to be added to output online distribution mains feature class        """        try:            dist_mains = os.path.join(gdb, "DistMains")            arcpy.AddMessage("Copy Features Dist Mains From Portal...")            from_meas_fld = "FROM_MEASURE"            to_meas_fld = "TO_MEASURE"            arcpy.management.CopyFeatures(in_features=infc,                                          out_feature_class=dist_mains,                                          config_keyword="",                                          spatial_grid_1=None,                                          spatial_grid_2=None,                                          spatial_grid_3=None)            field_list = arcpy.ListFields(dist_mains, from_meas_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{from_meas_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(dist_mains, from_meas_fld, "Double")                arcpy.AddMessage(f"Field '{from_meas_fld}' added successfully.")            arcpy.AddMessage("Calculate Geometry Attributes...")            arcpy.management.CalculateGeometryAttributes(in_features=dist_mains,                                                         geometry_property=to_meas_fld + " LENGTH_GEODESIC",                                                         length_unit="FEET_US",                                                         area_unit="",                                                         coordinate_system=None,                                                         coordinate_format="SAME_AS_INPUT")            field_list = arcpy.ListFields(dist_mains, unique_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{unique_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(dist_mains, unique_fld, "GUID")                arcpy.AddMessage(f"Field '{unique_fld}' added successfully.")            # Create an update cursor to calculate GUID values            with arcpy.da.UpdateCursor(dist_mains, [from_meas_fld, unique_fld]) as cursor:                for row in cursor:                    row[0] = 0                    # Generate a new GUID value                    guid_value = str(uuid.uuid4())                    # Update the row with the new GUID                    row[1] = guid_value                    cursor.updateRow(row)            arcpy.AddMessage(f"GUID values calculated and populated in the '{unique_fld}' field.")            arcpy.AddMessage("Creating route features...")            # create routes            arcpy.lr.CreateRoutes(                in_line_features=dist_mains,                route_id_field=unique_fld,                out_feature_class=dist_mains_routes,                measure_source="TWO_FIELDS",                from_measure_field=from_meas_fld,                to_measure_field=to_meas_fld,                coordinate_priority="UPPER_LEFT",                measure_factor=1,                measure_offset=0,                ignore_gaps="IGNORE",                build_index="INDEX"            )            arcpy.AddMessage("Join Field...")            arcpy.management.JoinField(                in_data=dist_mains_routes,                in_field=unique_fld,                join_table=dist_mains,                join_field=unique_fld,                fields=None,                fm_option="NOT_USE_FM",                field_mapping=None,                index_join_fields="NO_INDEXES"            )            field_list = arcpy.ListFields(dist_mains_routes, unique_fld+"_1")            if len(field_list) > 0:                arcpy.AddMessage("Delete Field...")                arcpy.management.DeleteField(dist_mains_routes,[unique_fld+"_1"])        except Exception as e:            raise    def add_message(self, parameters, msg, gp_msg_no, status_no):        try:            parameters[gp_msg_no].value = parameters[gp_msg_no].valueAsText + "\n " + msg            arcpy.AddMessage(msg)        except Exception as e:            parameters[gp_msg_no].value = parameters[gp_msg_no].valueAsText + "\n " + str(e)            parameters[status_no].value = "Error"            raise    def preprocess_audit_reads(self, audit_reads, out_gdb_name, audit_reads_fc, unique_fld):        """            Creates online audit reads features from input distribution mains features            audit_reads: Input audit reads features            out_gdb_name: Path of the geodatabase to save output online audit reads features            audit_reads_fc: Name of the output online audit reads feature class            unique_fld: Name of the GUID column to be added to output audit reads feature class        """        try:            arcpy.AddMessage("Copy Rows Audit Reads...")            arcpy.management.CopyRows(in_rows=audit_reads,                                        out_table=audit_reads_fc,                                        config_keyword="")            field_list = arcpy.ListFields(audit_reads_fc, unique_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{unique_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(audit_reads_fc, unique_fld, "GUID")                arcpy.AddMessage(f"Field '{unique_fld}' added successfully.")            # Create an update cursor to calculate GUID values            with arcpy.da.UpdateCursor(audit_reads_fc, [unique_fld]) as cursor:                for row in cursor:                    # Generate a new GUID value                    guid_value = str(uuid.uuid4())                    # Update the row with the new GUID                    row[0] = guid_value                    cursor.updateRow(row)        except Exception as e:            raise    def preprocess_casings(self, infc, gdb, casings_fc, unique_fld, dist_mains_routes, mains_unique_fld):        """            Creates online casings features from input distribution mains features            infc: Input casings features            gdb: Path of the geodatabase to save output online casings features            casings_fc: Name of the output online casings feature class            unique_fld: Name of the GUID column to be added to output casings feature class            dist_mains_routes: Input distribution mains features            mains_unique_fld:  Name of the distribution manins unique id column        """        try:            casings_fc = os.path.join(gdb, "Casings")            casings_m = os.path.join(gdb, "CasingsM")            casings_t = os.path.join(gdb, "CasingsEventsTable")            casings_rt = os.path.join(gdb, "CasingsRouteEvents")            arcpy.AddMessage("Copy Features Casings...")            arcpy.management.CopyFeatures(in_features=infc,                                  out_feature_class=casings_fc,                                  config_keyword="",                                  spatial_grid_1=None,                                  spatial_grid_2=None,                                  spatial_grid_3=None)            field_list = arcpy.ListFields(casings_fc, unique_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{unique_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(casings_fc, unique_fld, "GUID")                arcpy.AddMessage(f"Field '{unique_fld}' added successfully.")            # Create an update cursor to calculate GUID values            with arcpy.da.UpdateCursor(casings_fc, [unique_fld]) as cursor:                for row in cursor:                    # Generate a new GUID value                    guid_value = str(uuid.uuid4())                    # Update the row with the new GUID                    row[0] = guid_value                    cursor.updateRow(row)            arcpy.AddMessage("Locate Features Along Routes Casings...")            arcpy.lr.LocateFeaturesAlongRoutes(                in_features=casings_fc,                in_routes=dist_mains_routes,                route_id_field=mains_unique_fld,                radius_or_tolerance="2 Feet",                out_table=casings_t,                out_event_properties=mains_unique_fld + "; LINE; FROM_MEASURE; TO_MEASURE",                route_locations="FIRST",                distance_field="DISTANCE",                zero_length_events="ZERO",                in_fields="NO_FIELDS",                m_direction_offsetting="M_DIRECTON"            )            arcpy.AddMessage("Make Route Event Layer Casings...")            arcpy.lr.MakeRouteEventLayer(                in_routes=dist_mains_routes,                route_id_field=mains_unique_fld,                in_table=casings_t,                in_event_properties=mains_unique_fld + "; LINE; FROM_MEASURE; TO_MEASURE",                out_layer=casings_rt,                offset_field=None,                add_error_field="NO_ERROR_FIELD",                add_angle_field="NO_ANGLE_FIELD",                angle_type="NORMAL",                complement_angle="ANGLE",                offset_direction="LEFT",                point_event_type="POINT"            )            arcpy.AddMessage("Export Features Casings...")            arcpy.conversion.ExportFeatures(                in_features=casings_rt,                out_features=casings_m)            arcpy.AddMessage("Join Field Casings...")            arcpy.management.JoinField(                in_data=casings_m,                in_field="INPUTOID",                join_table=casings_fc,                join_field="OBJECTID",                fields=None,                fm_option="NOT_USE_FM",                field_mapping=None,                index_join_fields="NO_INDEXES"            )        except Exception as e:            raise    def execute(self, parameters, messages):        """The source code of the tool."""        arcpy.env.overwriteOutput = True        dist_mains = parameters[0].value        material_fld = parameters[1].valueAsText        plastic_material_val = int(parameters[2].value)        cp_section_fld = parameters[3].valueAsText#         cpsytem_fld = parameters[4].valueAsText        dist_mains_uniqueid_fld = parameters[4].valueAsText        audit_reads = parameters[5].value        py_annual_read_fld = parameters[6].valueAsText        py_casing_read_fld = parameters[7].valueAsText#         dist_trans_fld = parameters[9].valueAsText        section_fld = parameters[8].valueAsText        anuual_read_value = float(parameters[9].value)        shorted_read_value  = float(parameters[10].value)        reads_unique_id_fld = parameters[11].valueAsText        casings = parameters[12].value        is_shorted_fld = parameters[13].valueAsText        casings_uniquid_id_fld = parameters[14].valueAsText        out_gdb_name = parameters[15].valueAsText        output_table_name = parameters[16].valueAsText        cathodic_prot_table = os.path.join(out_gdb_name, output_table_name)        gp_msg_idx = 17        status_idx = 18#             parameters[gp_msg_idx].value = "Starting..."#             parameters[status_idx].value = "Success"        parameters[19].value = os.path.join(out_gdb_name, output_table_name)        portal_ulr = parameters[20].value        portal_username = parameters[21].value        portal_password = parameters[22].value        try:            reads_dist_fc = os.path.join(out_gdb_name, "M_CP_ReadsDist")            dist_mains_routes =  os.path.join(out_gdb_name, "DistMains_Routes")            audit_reads_fc = os.path.join(out_gdb_name, "AuditReads")            casings_fc = os.path.join(out_gdb_name, "CasingsM")            shorted_reads_fc = os.path.join(out_gdb_name, "M_CP_ShortedReads")            casings_reads_spjoin =  os.path.join(out_gdb_name, "M_CP_Casings_Reads_SpJoin")            mains_casings_spjoin =  os.path.join(out_gdb_name, "M_CP_Mains_Casings_SpJoin")            mains_cp_presennce_yes =  os.path.join(out_gdb_name, "DistMains_CP_Presence_Yes")            mains_cp_presennce_no =  os.path.join(out_gdb_name, "DistMains_CP_Presence_No")            mains_cp =  os.path.join(out_gdb_name, "M_CathodicProtection_FC")            shorted_casings = os.path.join(out_gdb_name, "Shorted_Casings")            casings_reads_spjoin_buffer =  os.path.join(out_gdb_name, "M_CP_Casings_Reads_SpJoin_Buffer")            mains_casings_buffer_intersect =  os.path.join(out_gdb_name, "M_CP_Mains_Casings_Buffer_Intersect")            mains_casings_erase =  os.path.join(out_gdb_name, "M_CP_Mains_Casings_Erase")            mains_casings_erase_1 =  os.path.join(out_gdb_name, "M_CP_Mains_Casings_Erase_1")            mains_casings_cp_section_select =  os.path.join(out_gdb_name, "M_CP_Mains_Casings_CP_Section_Select")            mains_casings_end_points =  os.path.join(out_gdb_name, "M_CP_Mains_Casings_End_Points")            mains_casings_end_points_intersect =  os.path.join(out_gdb_name, "M_CP_Mains_Casings_End_Points_Intersect")            mains_casings_select =  os.path.join(out_gdb_name, "M_CP_Mains_Casings_Select")            mains_casings_end_point = os.path.join(out_gdb_name, "M_CP_Mains_Casings_End_Point")            mains_casings_near_table =  os.path.join(out_gdb_name, "M_CP_Mains_Casings_Near_Table")            near_table_end_point =  os.path.join(out_gdb_name, "M_CP_Near_Table_End_Point")            near_table_end_point_project =  os.path.join(out_gdb_name, "M_CP_Near_Table_End_Point_Project")            mains_casings_split =  os.path.join(out_gdb_name, "M_CP_Mains_Casings_Split")            mains_casings_traced =  os.path.join(out_gdb_name, "M_CP_Mains_Casings_Traced")            cp_Temp =  os.path.join(out_gdb_name, "M_CP_Mains_Temp")            dist_mains_nonplastic_name = "DistMains_Routes_Metallic"            dist_mains_nonplastic =  os.path.join(out_gdb_name, dist_mains_nonplastic_name)            parameters[gp_msg_idx].value = "Starting..."            parameters[status_idx].value = ""            # sign in to portal            self.signin_portal(portal_ulr, portal_username, portal_password)            # check in dist mains exist in the file geodatabase            self.add_message(parameters, "Checking Input Dist Mains...", gp_msg_no, status_no)            if not arcpy.Exists(dist_mains_routes):                self.preprocess_distmains(dist_mains, out_gdb_name, dist_mains_routes, dist_mains_uniqueid_fld)            if not arcpy.Exists(audit_reads_fc):                self.preprocess_audit_reads(audit_reads, out_gdb_name, audit_reads_fc, reads_id_fld)            if not arcpy.Exists(casings_fc):                self.preprocess_casings(casings, out_gdb_name, casings_fc, casings_uniquid_id_fld, dist_mains_routes, dist_mains_uniqueid_fld)            if not arcpy.Exists(dist_mains_nonplastic):                # select non plastic distribution main                self.add_message(parameters, "Select Layer By Attribute Metallic Mains...", gp_msg_no, status_no)                whereclause = f"{material_fld} NOT IN ({plastic_material_val})"                dist_plastic = arcpy.management.SelectLayerByAttribute(in_layer_or_view=dist_mains_routes,                                        selection_type="NEW_SELECTION",                                        where_clause=whereclause,                                        invert_where_clause=None)                self.add_message(parameters, "Copy Features Metallic Mains...", gp_msg_no, status_no)                arcpy.management.CopyFeatures(in_features=dist_plastic,                                                out_feature_class=dist_mains_nonplastic,                                                config_keyword="",                                                spatial_grid_1=None,                                                spatial_grid_2=None,                                                spatial_grid_3=None)    #         cp_adequate_sql = f"{py_annual_read_fld} is not null AND {py_annual_read_fld} < {anuual_read_value}"    #         arcpy.AddMessage(cp_adequate_sql)            # check in dist mains exist in the file geodatabase#             arcpy.AddMessage("Select Layer By Attribute Distribution Audit Reads...")#             parameters[gp_msg_idx].value = parameters[gp_msg_idx].valueAsText + "\n Select Layer By Attribute Distribution Audit Reads..."#             sql = f"{dist_trans_fld} = 'Distribution'"#             arcpy.AddMessage(sql)#             reads_dist = arcpy.management.SelectLayerByAttribute(#                                     in_layer_or_view=audit_reads,#                                     selection_type="NEW_SELECTION",#                                     where_clause=sql,#                                     invert_where_clause=None)##             arcpy.AddMessage("Copy Features Distribution Audit Reads...")#             parameters[gp_msg_idx].value = parameters[gp_msg_idx].valueAsText + "\n Copy Features Distribution Audit Reads..."#             arcpy.management.CopyFeatures(in_features=reads_dist[0],#                                     out_feature_class=reads_dist_fc,#                                     config_keyword="",#                                     spatial_grid_1=None,#                                     spatial_grid_2=None,#                                     spatial_grid_3=None)            self.add_message(parameters, "Feature Class To NumPy Array Distribution Audit Reads...", gp_msg_no, status_no)            reads_arr = arcpy.da.FeatureClassToNumPyArray(in_table=audit_reads_fc,                                            field_names=("OBJECTID", py_annual_read_fld, section_fld,                                                        py_casing_read_fld, reads_id_fld),                                                        null_value= -9999)            reads_unique_sections = np.unique(reads_arr[section_fld])            reads_sections = {}            for section in reads_unique_sections:                rows = reads_arr[(reads_arr[section_fld] == section) & (reads_arr[py_annual_read_fld] != -9999)]                if len(rows) > 0:                    max_val = np.max(rows[py_annual_read_fld])                    unique_id = rows[rows[py_annual_read_fld] == max_val][0] [reads_id_fld]                    reads_sections[section.upper()] = {py_annual_read_fld: max_val,                                                        reads_id_fld: unique_id}            fields =[ cp_section_fld, CP_Presence_fld, CP_Mitigation_fld, annual_read_fld,                                        casing_read_fld, reads_id_fld]            # print(arcpy.management.GetCount(out_mains)[0])            self.add_message(parameters, "Calculating CP_Presence...", gp_msg_no, status_no)            with arcpy.da.UpdateCursor(dist_mains_nonplastic, fields) as cursor:                for row in cursor:                    cp_section = row[0]                    if cp_section and cp_section.upper() in reads_sections:                        try:                            read = reads_sections[cp_section]                            py_annual_read = read[py_annual_read_fld]                            reads_uniquid_id = read[reads_id_fld]                            row[3] = py_annual_read                            row[5] = reads_uniquid_id        #                     py_casing_read = read[py_casing_read_fld]        #                     row[4] = py_casing_read                            if py_annual_read == -9999 :                                row[1] = "No"                                row[2] = 0                            else:                                if py_annual_read < anuual_read_value:                                    row[1] = "Yes"                                    row[2] = 94                                else:                                    row[1] = "No"                                    row[2] = 0                        except Exception as e:                            tb = sys.exc_info()[2]                            self.add_message(parameters, str(e) + "\n" + "An error occurred on line %i" % tb.tb_lineno, gp_msg_no, status_no)                            parameters[status_idx].value = "Error"                            raise                    else:                        row[1] = "No"                        row[2] = 0                    cursor.updateRow(row)            # select cp adequate mains            self.add_message(parameters, "Select Layer By Attribute CP Presence Mains...", gp_msg_no, status_no)            sql = "CP_Presence = 'Yes'"            cp_dists_yes = arcpy.management.SelectLayerByAttribute(in_layer_or_view=dist_mains_nonplastic,                                    selection_type="NEW_SELECTION",                                    where_clause=sql,                                    invert_where_clause=None)            self.add_message(parameters, "Copy Features CP Presence Mains...", gp_msg_no, status_no)            arcpy.management.CopyFeatures(in_features=cp_dists_yes,                                    out_feature_class=mains_cp_presennce_yes,                                    config_keyword="",                                    spatial_grid_1=None,                                    spatial_grid_2=None,                                    spatial_grid_3=None)            # select cp adequate mains            self.add_message(parameters, "Select Layer By Attribute CP Presence Mains...", gp_msg_no, status_no)            sql = "CP_Presence = 'No'"            cp_dists_no = arcpy.management.SelectLayerByAttribute(in_layer_or_view=dist_mains_nonplastic,                                    selection_type="NEW_SELECTION",                                    where_clause=sql,                                    invert_where_clause=None)            self.add_message(parameters, "Copy Features CP Presence Mains...", gp_msg_no, status_no)            arcpy.management.CopyFeatures(in_features=cp_dists_no,                                    out_feature_class=mains_cp_presennce_no,                                    config_keyword="",                                    spatial_grid_1=None,                                    spatial_grid_2=None,                                    spatial_grid_3=None)            # select shorted casings            self.add_message(parameters, "Select Layer By Attribute Shorted Casings...", gp_msg_no, status_no)            sql = f"{is_shorted_fld} = 'Yes'"            arcpy.AddMessage(sql)            casings_sel = arcpy.management.SelectLayerByAttribute(in_layer_or_view=casings_fc,                                    selection_type="NEW_SELECTION",                                    where_clause=sql,                                    invert_where_clause=None)            self.add_message(parameters, "Copy Features Shorted Casings...", gp_msg_no, status_no)            arcpy.management.CopyFeatures(in_features=casings_sel,                                    out_feature_class=shorted_casings,                                    config_keyword="",                                    spatial_grid_1=None,                                    spatial_grid_2=None,                                    spatial_grid_3=None)#             shorted_sql = f"{py_annual_read_fld} is not null AND {py_casing_read_fld} is not null and abs({py_annual_read_fld} - {py_casing_read_fld}) <= {shorted_read_value}"#             arcpy.AddMessage(shorted_sql)#             # select CP adequate audit reads#             arcpy.AddMessage("Select Layer By Attribute Shorted Audit Reads...")#             parameters[gp_msg_idx].value = parameters[gp_msg_idx].valueAsText + "\n Select Layer By Attribute Shorted Audit Reads..."#             shorted_reads = arcpy.management.SelectLayerByAttribute(in_layer_or_view=audit_reads,#                             selection_type="NEW_SELECTION",#                             where_clause=shorted_sql,#                             invert_where_clause=None)##             # copy CP adequate audit reads#             arcpy.AddMessage("Copy Features Shorted Audit Reads...")#             parameters[gp_msg_idx].value = parameters[gp_msg_idx].valueAsText + "\n Copy Features Shorted Audit Reads..."#             arcpy.management.CopyFeatures(in_features=shorted_reads[0],#                                     out_feature_class=shorted_reads_fc,#                                     config_keyword="",#                                     spatial_grid_1=None,#                                     spatial_grid_2=None,#                                     spatial_grid_3=None)#             arcpy.AddMessage( "Shorted Audit Reads count: " + arcpy.management.GetCount(shorted_reads_fc)[0])#             if int(arcpy.management.GetCount(shorted_reads_fc)[0]) < 1:#                 arcpy.AddMessage( "There are no shorted audit reads! ")#                 parameters[gp_msg_idx].value = parameters[gp_msg_idx].valueAsText + "\n There are no shorted audit reads!"#                 arcpy.management.CopyFeatures(in_features=cp_Temp,#                                     out_feature_class=cathodic_prot_table,#                                     config_keyword="",#                                     spatial_grid_1=None,#                                     spatial_grid_2=None,#                                     spatial_grid_3=None)#                 parameters[gp_msg_idx].value = parameters[gp_msg_idx].valueAsText + "\n Finished!"#                 return##             # spatial join casings and shorted reads#             arcpy.AddMessage("Spatial Join Casings Shorted Audit Reads...")#             arcpy.analysis.SpatialJoin(target_features=casings,#                                     join_features=shorted_reads_fc,#                                     out_feature_class=casings_reads_spjoin,#                                     join_operation="JOIN_ONE_TO_ONE",#                                     join_type="KEEP_COMMON",#                                     match_option="INTERSECT",#                                     search_radius="10 Feet",#                                     distance_field_name="",#                                     match_fields=None)#             arcpy.AddMessage( "casings_reads_spjoin count: " + arcpy.management.GetCount(casings_reads_spjoin)[0])#             if int(arcpy.management.GetCount(casings_reads_spjoin)[0]) < 1:#                 arcpy.AddMessage( "There are no shorted casings! ")#                 parameters[gp_msg_idx].value = parameters[gp_msg_idx].valueAsText + "\n There are no shorted casings!"#                 arcpy.management.CopyFeatures(in_features=cp_Temp,#                                     out_feature_class=cathodic_prot_table,#                                     config_keyword="",#                                     spatial_grid_1=None,#                                     spatial_grid_2=None,#                                     spatial_grid_3=None)#                 parameters[gp_msg_idx].value = parameters[gp_msg_idx].valueAsText + "\n Finished!"#                 return            self.add_message(parameters, "Spatial Join Casings and Mains...", gp_msg_no, status_no)            arcpy.analysis.SpatialJoin(target_features=shorted_casings,                                    join_features=mains_cp_presennce_no,                                    out_feature_class=mains_casings_spjoin,                                    join_operation="JOIN_ONE_TO_ONE",                                    join_type="KEEP_COMMON",                                    match_option="SHARE_A_LINE_SEGMENT_WITH",                                    search_radius="0 Feet",                                    distance_field_name="",                                    match_fields=None)#             arcpy.AddMessage( "mains_casings_spjoin count: " + arcpy.management.GetCount(mains_casings_spjoin)[0])#             if int(arcpy.management.GetCount(mains_casings_spjoin)[0]) < 1:#                 arcpy.AddMessage( "There are no shorted casings connected to mains! ")#                 parameters[gp_msg_idx].value = parameters[gp_msg_idx].valueAsText + "\n There are no shorted casings connected to mains!"#                 arcpy.management.CopyFeatures(in_features=cp_Temp,#                                     out_feature_class=cathodic_prot_table,#                                     config_keyword="",#                                     spatial_grid_1=None,#                                     spatial_grid_2=None,#                                     spatial_grid_3=None)#                 parameters[gp_msg_idx].value = parameters[gp_msg_idx].valueAsText + "\n Finished!"#                 return            self.add_message(parameters, "Feature Vertices To Points Casings Mains...", gp_msg_no, status_no)            arcpy.management.FeatureVerticesToPoints(in_features=mains_casings_spjoin,                                    out_feature_class=mains_casings_end_point,                                    point_location="BOTH_ENDS")            self.add_message(parameters, "Pairwise Buffer To Casings Mains...", gp_msg_no, status_no)            arcpy.analysis.PairwiseBuffer(in_features=mains_casings_spjoin,                                out_feature_class=casings_reads_spjoin_buffer,                                buffer_distance_or_field="100 Feet",                                dissolve_option="NONE",                                dissolve_field=None,                                method="GEODESIC",                                max_deviation="0 Meters")            self.add_message(parameters, "Pairwise Intersect To Mains And Buffers...", gp_msg_no, status_no)            infeatures = [dist_mains_nonplastic, casings_reads_spjoin_buffer]            arcpy.analysis.PairwiseIntersect(in_features=infeatures,                                        out_feature_class=mains_casings_buffer_intersect,                                        join_attributes="ONLY_FID",                                        cluster_tolerance=None,                                        output_type="LINE")            self.add_message(parameters, "Split Line At Point Mains Buffers...", gp_msg_no, status_no)            arcpy.management.SplitLineAtPoint(in_features=mains_casings_buffer_intersect,                                    point_features=mains_casings_end_point,                                    out_feature_class=mains_casings_split,                                    search_radius="1 Feet")            self.add_message(parameters, "Tracing Connected Mains To End Points...", gp_msg_no, status_no)            self.trace_lines_connected_to_point(mains_casings_split, mains_casings_end_point, mains_casings_traced)            self.add_message(parameters, "Pairwise Erase...", gp_msg_no, status_no)            arcpy.analysis.PairwiseErase(in_features=mains_casings_traced,                        erase_features=mains_casings_spjoin,                        out_feature_class=mains_casings_erase,                        cluster_tolerance="0 Feet")            arcpy.management.JoinField(in_data=mains_casings_erase,                                    in_field="FID_" + dist_mains_nonplastic_name, # + output_table_name,                                    join_table=dist_mains_nonplastic,                                    join_field="OBJECTID",                                    fields=None,                                    fm_option="NOT_USE_FM",                                    field_mapping=None,                                    index_join_fields="NO_INDEXES")            self.add_message(parameters, "Calculate Field CP_Mitigation...", gp_msg_no, status_no)            arcpy.management.CalculateField(in_table=mains_casings_erase,                                            field=CP_Mitigation_fld,                                            expression="0",                                            expression_type="PYTHON3",                                            code_block="",                                            field_type="TEXT",                                            enforce_domains="NO_ENFORCE_DOMAINS")            self.add_message(parameters, "Pairwise Erase 2...", gp_msg_no, status_no)            arcpy.analysis.PairwiseErase(in_features=dist_mains_nonplastic,                                    erase_features=mains_casings_erase,                                    out_feature_class=mains_casings_erase_1,                                    cluster_tolerance="2 Feet")            in_layers = [mains_casings_erase, mains_casings_erase_1]            self.add_message(parameters, "Merging Mains...", gp_msg_no, status_no)            arcpy.management.Merge(inputs=in_layers,                                    output=mains_cp,                                    add_source="NO_SOURCE_INFO")            self.add_message(parameters, "Creating output linear events table...", gp_msg_no, status_no)            arcpy.lr.LocateFeaturesAlongRoutes(in_features=mains_cp,                                            in_routes=dist_mains_nonplastic,                                            route_id_field=dist_mains_uniqueid_fld,                                            radius_or_tolerance="0 Meters",                                            out_table=cathodic_prot_table,                                            out_event_properties= dist_mains_uniqueid_fld + "; LINE; FROM_MEASURE; TO_MEASURE",                                            route_locations="FIRST",                                            distance_field="DISTANCE",                                            zero_length_events="ZERO",                                            in_fields="FIELDS",                                            m_direction_offsetting="M_DIRECTON")            self.add_message(parameters, "Finished!", gp_msg_no, status_no)            parameters[status_idx].value = "Success"            return        except Exception as e:            parameters[status_idx].value = "Error"            self.add_message(parameters, str(e), gp_msg_no, status_no)    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return