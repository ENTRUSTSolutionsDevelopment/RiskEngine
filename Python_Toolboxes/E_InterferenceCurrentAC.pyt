# -*- coding: utf-8 -*-####################################################################################################################### Copyright © 2025 Entrust Solutions Group.# All Rights Reserved.# Threat Risk:#       Corrosion# Variable Type:#       Exposure# Variable:#       Interference Currents - AC# Variable Description:#       only apply to areas with parallel electric lines, see if they have done an analysis –#       if so they will have more hot spot information, if no analysis apply to whole corridor,#       get general mpy from corrosion; see if they have monitoring if they have monitoring,#       should be able to pull data from that; there are also monitoring for personnel safety and#       then mitigation for protection pipeline; need model set up to be able to handle data#       from survey/analysis#       Refer to functional requirements for interference corrosion - AC for geoprocessing instructions.#       Per the functional requirements, each segment will be assinged an ac_interference_index value.#       Use this value in the linear relationship defined by these points:#       x = [17,26] and y = [5,400], where x is the ac_interference_index and y is the corrosion term in mils / year.# Units:#       mpy# Source(s):#       Distribution Mains#           URL: https://ene.maps.arcgis.com/home/item.html?id=cd0407318f46497ea53201ed9b19a884#       Electric Power Lines#             URL: https://www.arcgis.com/home/item.html?id=d4090758322c4d32a4cd002ffaa0aa12# Field Name(s):#       N/A# Tier 1 Determination Method:#       Requirements documnet Location:#           I:\IN\0 Client\Avangrid\Projects\2309043.00 RGE_NYSEG DIMP Risk Model\#           \2.0 Working Data\DS\geoprocessing functional requirements drafts#           \Geoprocessing Requirements Interference Currents - AC_v1.docx# Tier 1 Determination Method Source(s):#       N/A# Tier 2 Determination Method:#       N/A# Tier 2 Determination Method Source(s):#       N/A# Tier 3 Determination Method:#      N/A# Tier 3 Determination Method Source(s):#       N/A########################################################################################################################import arcpyimport numpy as npimport osimport uuid# online distribution mains feature class name,# this feature class will be created in the output GDB if it does not existDIST_MAINS_FC_NAME = "DistMains_Routes"# New fields to addSeparation_Distance_fld = "Separation_Distance"Separation_Distance_Index_fld = "Separation_Distance_Index"Voltage_fld = "Voltage"Current_Index_fld = "Current_Index"Coating_Condition_Index_fld = "Coating_Condition_Index"Collocation_Length_fld = "Collocation_Length"Collocation_Length_Index_fld = "Collocation_Length_Index"Crossing_Angle_fld = "Crossing_Angle"Crossing_Angle_Index_fld = "Crossing_Angle_Index"AC_Interference_Index_fld = "AC_Interference_Index"AC_Interference_Corrosion_fld = "AC_Interference_Corrosion"Distance_Ft_fld = "Distance_Ft"DIST_MAINS_FIELD_DESCRIPTION = [[Separation_Distance_fld, "Double", Separation_Distance_fld, None],                                [Separation_Distance_Index_fld, "Long", Separation_Distance_Index_fld, None],                                [Voltage_fld, "Double", Voltage_fld, None],                                [Current_Index_fld, "Long", Current_Index_fld, None],                                [Coating_Condition_Index_fld, "Long", Coating_Condition_Index_fld, None],                                [Collocation_Length_fld, "Double", Collocation_Length_fld, None],                                [Collocation_Length_Index_fld, "Long", Collocation_Length_Index_fld, None],                                [Crossing_Angle_fld, "Double", Crossing_Angle_fld, None],                                [Crossing_Angle_Index_fld, "Long", Crossing_Angle_Index_fld, None],                                [AC_Interference_Index_fld, "Long", AC_Interference_Index_fld, None],                                [AC_Interference_Corrosion_fld, "Double", AC_Interference_Corrosion_fld, None],                                [Distance_Ft_fld, "TEXT", Distance_Ft_fld, 20]                              ]# calculate linear relationship between ac ac_interference_idx and ac_corrosion#       Use this value in the linear relationship defined by these points:#       x = [17,26] and y = [5,400], where x is the ac_interference_index and y is the corrosion term in mils / year.x_boundary_values = [17, 26]  # Given x valuesy_boundary_values = [5, 400]  # Given y valuesclass Toolbox:    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [E_InterferenceCurrentAC]class E_InterferenceCurrentAC:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "E_InterferenceCurrentAC"        self.description = ""    def getParameterInfo(self):        """Define the tool parameters."""        params = []        in_dist_mains = arcpy.Parameter(            displayName="Input Distribution Mains Features", name="in_dist_mains",            datatype="GPFeatureLayer", parameterType="Required",            direction="Input")        route_id_fld = arcpy.Parameter(            displayName="Input Route ID Field",            name="route_id_fld",            datatype="Field",            parameterType="Required",            direction="Input")        route_id_fld.parameterDependencies = [in_dist_mains.name]        material_fld = arcpy.Parameter(            displayName="Input Material Type Field",            name="material_fld",            datatype="Field",            parameterType="Required",            direction="Input")        material_fld.parameterDependencies = [in_dist_mains.name]        plastic_material_val = arcpy.Parameter(            displayName="Input Plastic Material Type Value",            name="plastic_material_val",            datatype="GPLong",            parameterType="Required",            direction="Input")        coating_type_fld = arcpy.Parameter(            displayName="Input Coating Type Field",            name="coating_type_fld",            datatype="Field",            parameterType="Required",            direction="Input")        coating_type_fld.parameterDependencies = [in_dist_mains.name]        cp_section_fld = arcpy.Parameter(            displayName="Input CP Section Field",            name="cp_section_fld",            datatype="Field",            parameterType="Required",            direction="Input")        cp_section_fld.parameterDependencies = [in_dist_mains.name]        in_power_lines = arcpy.Parameter(            displayName="Input Electric Power Lines Features", name="in_power_lines",            datatype="GPFeatureLayer", parameterType="Required",            direction="Input")        voltage_fld = arcpy.Parameter(            displayName="Input Voltage Field",            name="voltage_fld",            datatype="Field",            parameterType="Required",            direction="Input")        voltage_fld.parameterDependencies = [in_power_lines.name]        out_gdb = arcpy.Parameter(            displayName="Output GDB Name",            name="out_gdb",            datatype="GPString",            parameterType="Optional",            direction="Input")#         out_gdb.value = r"C:\temp\RiskEngine.gdb"        out_ac_corrosion_table = arcpy.Parameter(            displayName="Output AC Interference Corrosion Table",            name="out_ac_corrosion_table",            datatype="GPString",            parameterType="Optional",            direction="Input")#         out_ac_corrosion_table.value = "E_AC_InterferenceCurrent"        gp_messages = arcpy.Parameter(            displayName="Geoprocessing Messages",            name="gp_messages",            datatype="GPString",            parameterType="Optional",            direction="Output")        status = arcpy.Parameter(            displayName="Tool Status",            name="status",            datatype="GPString",            parameterType="Optional",            direction="Output")        # param 20        output_table = arcpy.Parameter(            displayName="Output Linear Events Table",            name="output_table",            datatype="GPTableView",            parameterType="Optional",            direction="Output")        # param 21        portal_ulr = arcpy.Parameter(            displayName="ArcGIS Portal URL",            name="portal_ulr",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 22        portal_username = arcpy.Parameter(            displayName="ArcGIS Portal User Name",            name="portal_username",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 23        portal_password = arcpy.Parameter(            displayName="ArcGIS Portal Password",            name="portal_password",            datatype="GPStringHidden",            parameterType="Optional",            direction="Input")        params = [in_dist_mains, route_id_fld, material_fld, plastic_material_val, coating_type_fld, cp_section_fld,                    in_power_lines, voltage_fld, out_gdb, out_ac_corrosion_table, gp_messages, status,                    output_table, portal_ulr, portal_username, portal_password]        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    def signin_portal(self, portal_url, username, password):        """            Login to the ArcGIS Portal to access input data sources            portal_url: ArcGIS Portal URL            username: User name            password: Password        """        if arcpy.GetSigninToken() is None:            try:                if username is not None and  password is not None:                    arcpy.SignInToPortal(portal_url, username, password)                else:                    arcpy.SignInToPortal(portal_url)                arcpy.AddMessage("ArcGIS Portal Login Successful.")            except Exception as e:                arcpy.AddError("ArcGIS Portal Login Failed!."                                "\n{}".format(arcpy.GetMessages(2)))                raise    def preprocess_distmains(self, infc, gdb, dist_mains_routes, unique_fld):        """            Creates online distribution mains features from input distribution mains features            infc: Input distribution mains features            gdb: Path of the geodatabase to save output online distribution mains features            dist_mains_routes: Name of the output online distribution mains feature class            unique_fld: Name of the GUID column to be added to output online distribution mains feature class        """        try:            dist_mains = os.path.join(gdb, "DistMains")            arcpy.AddMessage("Copy Features Dist Mains From Portal...")            from_meas_fld = "FROM_MEASURE"            to_meas_fld = "TO_MEASURE"            arcpy.management.CopyFeatures(in_features=infc,                                          out_feature_class=dist_mains,                                          config_keyword="",                                          spatial_grid_1=None,                                          spatial_grid_2=None,                                          spatial_grid_3=None)            field_list = arcpy.ListFields(dist_mains, from_meas_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{from_meas_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(dist_mains, from_meas_fld, "Double")                arcpy.AddMessage(f"Field '{from_meas_fld}' added successfully.")            arcpy.AddMessage("Calculate Geometry Attributes...")            arcpy.management.CalculateGeometryAttributes(in_features=dist_mains,                                                         geometry_property=to_meas_fld + " LENGTH_GEODESIC",                                                         length_unit="FEET_US",                                                         area_unit="",                                                         coordinate_system=None,                                                         coordinate_format="SAME_AS_INPUT")            field_list = arcpy.ListFields(dist_mains, unique_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{unique_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(dist_mains, unique_fld, "GUID")                arcpy.AddMessage(f"Field '{unique_fld}' added successfully.")            # Create an update cursor to calculate GUID values            with arcpy.da.UpdateCursor(dist_mains, [from_meas_fld, unique_fld]) as cursor:                for row in cursor:                    row[0] = 0                    # Generate a new GUID value                    guid_value = str(uuid.uuid4())                    # Update the row with the new GUID                    row[1] = guid_value                    cursor.updateRow(row)            arcpy.AddMessage(f"GUID values calculated and populated in the '{unique_fld}' field.")            arcpy.AddMessage("Creating route features...")            # create routes            arcpy.lr.CreateRoutes(                in_line_features=dist_mains,                route_id_field=unique_fld,                out_feature_class=dist_mains_routes,                measure_source="TWO_FIELDS",                from_measure_field=from_meas_fld,                to_measure_field=to_meas_fld,                coordinate_priority="UPPER_LEFT",                measure_factor=1,                measure_offset=0,                ignore_gaps="IGNORE",                build_index="INDEX"            )            arcpy.AddMessage("Join Field...")            arcpy.management.JoinField(                in_data=dist_mains_routes,                in_field=unique_fld,                join_table=dist_mains,                join_field=unique_fld,                fields=None,                fm_option="NOT_USE_FM",                field_mapping=None,                index_join_fields="NO_INDEXES"            )            field_list = arcpy.ListFields(dist_mains_routes, unique_fld+"_1")            if len(field_list) > 0:                arcpy.AddMessage("Delete Field...")                arcpy.management.DeleteField(dist_mains_routes,[unique_fld+"_1"])        except Exception as e:            raise    def add_message(self, parameters, msg, gp_msg_no, status_no):        try:            parameters[gp_msg_no].value = parameters[gp_msg_no].valueAsText + "\n " + msg            arcpy.AddMessage(msg)        except Exception as e:            parameters[gp_msg_no].value = parameters[gp_msg_no].valueAsText + "\n " + str(e)            parameters[status_no].value = "Error"            raise    def get_seperation_dist_index(self, dist):        '''            Returns the seperation distance index using the table below            dist: input distance value            Separation Distance Index:                Separation Distance Value Ranges   Separation Distance Index                ≤ 100 feet                          5                > 100 feet & ≤ 500 feet             3                > 500 feet & ≤ 1,000 feet           2                > 1,000 feet & ≤ 2,500 feet         1        '''        try:            if dist <= 100:                return 5            elif 100 < dist  <= 500:                return 3            elif 500 < dist <= 1000:                return 2            else:                return 1        except Exception as e:            raise    def get_collocation_index(self, dist):        '''            Returns the Collocation Length Index using the table below            dist: input distance value            Collocation Length:                Collocation Length Ranges   Collocation Length Index                ≥ 5,000 feet                    5                < 5,000 feet & ≥ 1,000 feet     3                < 1,000 feet                    2        '''        try:            if dist < 1000:                return 2            elif 1000 <= dist < 5000:                return 3            else:                return 5        except Exception as e:            raise    def get_current_index(self, voltage):        '''            Returns the Current Index using the table below            voltage: input voltage value            Current Index:            Use Current values if available, otherwise use voltage value.                Current Value Ranges    Voltage Value Ranges    Current Index                Null                    -999999                     6                ≥1,000 A                ≥ 500 kV                    6                < 1,000 A & ≥ 500 A     < 500 kV & ≥ 230 kV         5                < 500 A & ≥ 250 A       < 230 kV & ≥ 138 kV         4                < 250 A & ≥ 100 A       < 138 kV & ≥ 69 kV          3            When current and voltage values are unknown, return a Current Index value of 6.                 2        '''        try:            if voltage >= 500:                return 6            elif 230 <= voltage < 500:                return 5            elif 138 <= voltage < 230:                return 4            else:                return 3        except Exception as e:            raise    def calc_coating_cond_idx(self, type):        '''            Returns the Coating Condition Index using the table below            type: input coating type value            Use Coating Condition if available, otherwise use Coating Type                Coating Condition Value Coating Condition Index                Excellent                           5                Good                                3                Fair                                2                None                                0                Coating Type Value Coating                                      Condition Index                Null 5                FBE with 3-Layer Polyethylene and Polypropylene (Pri-Tec)       5                Fusion Bonded Epoxy (FBE)                                       3                Coal Tar Enamel, Asphalt Enamel                                 2                Coated and Wrapped                                              2                Other                                                           2                Scotch Kote                                                     2                Scotch Wrap                                                     2                Wrapped                                                         2                Unknown                                                         2        '''        try:            if type is None or type.strip() == "":                return 5            elif type == "EPX":                return 3            elif type in ["C&W", "CTE", "OTH", "SK", "SW", "UNK", "WRAP" ]:                return 2            elif type == "BAR":                return 0            else:                return 2        except Exception as e:            raise    def get_crossing_angle_index(self, angle):        '''            Returns the Crossing Angle Index using the table below            dist: input distance value            Crossing Angle Degree Ranges Crossing Angle Index                ≤ 30°                       5                > 30° & ≥ 60°               3                < 60°                       2        '''        try:            if angle <= 30:                return  5            elif 30 < angle <= 60:                return 3            else:                return 2        except Exception as e:            raise    def linear_interpolation(self, x_values, y_values, x_to_interpolate):        '''        # Calculates the Y interpolated value        x_values: input x valus [17,26]        y_values: input y values: [5,400]        x_to_interpolate: input x value to interpolate y value        # calculate linear relationship between ac ac_interference_idx and ac_corrosion        # Use this value in the linear relationship defined by these points:        #x = [17,26] and y = [5,400], where x is the ac_interference_index and y is the corrosion term in mils / year.        '''        try:            x1, x2 = x_values            y1, y2 = y_values            if x_to_interpolate <= x1:                return y1  # Handle cases below the lower bound.            if x_to_interpolate >= x2:                return y2  # Handle cases above the upper bound.            # Linear interpolation formula: y = y1 + (x - x1) * (y2 - y1) / (x2 - x1)            if x2 - x1 == 0:                return y1 # avoid division by zero            else:                y_interpolated = y1 + (x_to_interpolate - x1) * (y2 - y1) / (x2 - x1)                return y_interpolated        except Exception as e:            raise    def update_dist_mains(self, dist_mains_singlepart_lyr, results):        '''            Updated the distribution mains feature class            dist_mains_singlepart_lyr: input distribution mains feature class            results: input values used to update distribution mains        '''        try:            fields =[ "OBJECTID",                      Separation_Distance_fld, Separation_Distance_Index_fld,                      Voltage_fld, Current_Index_fld,                      Coating_Condition_Index_fld,                      Collocation_Length_fld,  Collocation_Length_Index_fld,                      Crossing_Angle_fld, Crossing_Angle_Index_fld,                      AC_Interference_Index_fld, AC_Interference_Corrosion_fld]            with arcpy.da.UpdateCursor(dist_mains_singlepart_lyr, fields) as cursor:                for row in cursor:                    objid = row[0]                    result = results[objid]                    row[1] = round(result[Separation_Distance_fld], 2)                    row[2] = result[Separation_Distance_Index_fld]                    row[3] = result[Voltage_fld]                    row[4] = result[Current_Index_fld]                    row[5] = result[Coating_Condition_Index_fld]                    row[6] = round(result[Collocation_Length_fld], 2)                    row[7] = result[Collocation_Length_Index_fld]                    row[8] = round(result[Crossing_Angle_fld], 2)                    row[9] = result[Crossing_Angle_Index_fld]                    row[10] = result[AC_Interference_Index_fld]                    row[11] = round(result[AC_Interference_Corrosion_fld], 1)                    cursor.updateRow(row)        except Exception as e:            raise    def execute(self, parameters, messages):        """The source code of the tool."""        x_min, x_max = x_boundary_values        y_min, y_max = y_boundary_values        x_values_to_calculate = list(range(x_min+1, x_max))        xy_linear_relation = {}        for x in x_values_to_calculate:            y = self.linear_interpolation(x_boundary_values, y_boundary_values, x)            xy_linear_relation[x] = y        arcpy.env.overwriteOutput = True        dist_mains = parameters[0].value        route_id_fld = parameters[1].valueAsText        material_fld = parameters[2].valueAsText        plastic_material_val = int(parameters[3].value)        coating_type_fld = parameters[4].valueAsText        cp_section_fld = parameters[5].valueAsText        power_lines = parameters[6].value        voltage_fld = parameters[7].valueAsText        out_gdb = parameters[8].valueAsText        output_table_name = parameters[9].valueAsText        gp_msg_no = 10        status_no = 11        parameters[12].value = os.path.join(out_gdb_name, out_excav_damage_table)        portal_ulr = parameters[13].value        portal_username = parameters[14].value        portal_password = parameters[15].value        parameters[gp_msg_no].value = "Starting..."        parameters[status_no].value = ""#         output_table_name = parameters[6].valueAsText##         output_table_name = os.path.join(out_gdb_name, output_table_name)#         # TODO update the out put folder#         out_folder = r"C:\temp"#         out_gdb_name = "RiskEngine.gdb"#         out_gdb = os.path.join(out_folder, out_gdb_name)#         # check if file gdb exists#         if not arcpy.Exists(out_gdb):#             arcpy.management.CreateFileGDB(out_folder, out_gdb_name)        try:            output_table_path = os.path.join(out_gdb, output_table_name)            ring_buff_lyr = os.path.join(out_gdb, "AC_Interference_Corrosion_Elec_Buffers")            buffer_fld_name = "distance"            buffer_ft_fld_name = "Distance_Ft"            dist_mains_intersect_lyr = os.path.join(out_gdb,"dist_mains_intersect_lyr")            dist_mains_singlepart_lyr = os.path.join(out_gdb,"dist_mains_single_part")            dist_mains_output_table = os.path.join(out_gdb, "E_AC_Interference_Corrosion")            dist_mains_to_powerline_neartable = os.path.join(out_gdb, "dist_mains_to_powerline_neartable")            dist_mains_stats_table = os.path.join(out_gdb,"dist_mains_stats_table")            dist_mains_stats_table_cpsection = os.path.join(out_gdb,"dist_mains_stats_table_cpsection")            dist_mains_stats_table_cpsection_null = os.path.join(out_gdb,"dist_mains_stats_table_cpsection_null")            dist_mains_stats_fc = os.path.join(out_gdb,"AC_Interference_Corrosion_Dist_Mains")            dist_mains_singlepart_buf_name = "DistMains_Buffer"            dist_mains_singlepart_bufF_lyr = os.path.join(out_gdb, dist_mains_singlepart_buf_name)            power_lines_intersect_lyr = os.path.join(out_gdb, "power_lines_intersect_lyr")            power_lines_intersect_singlepart_lyr = os.path.join(out_gdb, "AC_power_lines_intersect_singlepart_lyr")            dist_mains_routes =  os.path.join(out_gdb_name, DIST_MAINS_FC_NAME)            cp_Temp =  os.path.join(out_gdb, "E_Mains_Metallic")            elec_Temp =  os.path.join(out_gdb, "E_Electric_Lines")            elec_Temp_select =  os.path.join(out_gdb, "E_Electric_Lines_Selected")            # sign in to portal            self.signin_portal(portal_ulr, portal_username, portal_password)            # check in dist mains exist in the file geodatabase            self.add_message(parameters, "Checking Input Dist Mains...", gp_msg_no, status_no)            if not arcpy.Exists(dist_mains_routes):    #             # sign in to portal    #             self.signin_portal(portal_ulr, portal_username, portal_password)                self.preprocess_distmains(dist_mains, out_gdb_name, dist_mains_routes, route_id_fld)            # select non plastic distribution main            self.add_message(parameters, "Select Layer By Attribute NonPlastic Mains...", gp_msg_no, status_no)            whereclause = f"{material_fld} NOT IN ({plastic_material_val})"            dist_plastic = arcpy.management.SelectLayerByAttribute(in_layer_or_view=dist_mains_routes,                                    selection_type="NEW_SELECTION",                                    where_clause=whereclause,                                    invert_where_clause=None)            self.add_message(parameters, "Copy Features NonPlastic Mains...", gp_msg_no, status_no)            arcpy.management.CopyFeatures(in_features=dist_plastic[0],                                            out_feature_class=cp_Temp,                                            config_keyword="",                                            spatial_grid_1=None,                                            spatial_grid_2=None,                                            spatial_grid_3=None)            self.add_message(parameters, "Copy Features Electric Lines...", gp_msg_no, status_no)            arcpy.management.CopyFeatures(in_features=power_lines,                                            out_feature_class=elec_Temp,                                            config_keyword="",                                            spatial_grid_1=None,                                            spatial_grid_2=None,                                            spatial_grid_3=None)            self.add_message(parameters, "Select Layer By Location Electric Lines...", gp_msg_no, status_no)            ele_select = arcpy.management.SelectLayerByLocation(in_layer=elec_Temp,                                        overlap_type="WITHIN_A_DISTANCE",                                        select_features=cp_Temp,                                        search_distance="2000 Feet",                                        selection_type="NEW_SELECTION",                                        invert_spatial_relationship="NOT_INVERT")            self.add_message(parameters, "Copy Features Selected Electric Lines...", gp_msg_no, status_no)            arcpy.management.CopyFeatures(in_features=ele_select,                                            out_feature_class=elec_Temp_select,                                            config_keyword="",                                            spatial_grid_1=None,                                            spatial_grid_2=None,                                            spatial_grid_3=None)            self.add_message(parameters, "Creating multple ring buffer polugons to power lines...", gp_msg_no, status_no)            # create multple ring buffer polugons on power lines            arcpy.analysis.MultipleRingBuffer( Input_Features=elec_Temp_select,                                        Output_Feature_class=ring_buff_lyr,                                        Distances=[100,500,1000,2500],                                        Buffer_Unit="Feet",                                        Field_Name=buffer_fld_name,                                        Dissolve_Option="ALL",                                        Outside_Polygons_Only="FULL",                                        Method="GEODESIC")            self.add_message(parameters, "Interseting non plastic mains with buffer polygons...", gp_msg_no, status_no)            infeatures = [cp_Temp, ring_buff_lyr]            arcpy.analysis.PairwiseIntersect(in_features=infeatures,                                        out_feature_class=dist_mains_intersect_lyr,                                        join_attributes="ALL",                                        cluster_tolerance=None,                                        output_type="LINE")            self.add_message(parameters, "Convering interseted features to single part...", gp_msg_no, status_no)            # convert intersect features to single part            arcpy.management.MultipartToSinglepart(in_features=dist_mains_intersect_lyr,                                            out_feature_class=dist_mains_singlepart_lyr)            self.add_message(parameters, "Calculate Geometry Attributes...", gp_msg_no, status_no)            # calculate geometry attributes            arcpy.management.CalculateGeometryAttributes(in_features=dist_mains_singlepart_lyr,                                            geometry_property="MAINS_BEARING LINE_BEARING;SEGMENT_LENGTH LENGTH_GEODESIC",                                            length_unit="FEET_US",                                            area_unit="",                                            coordinate_system=None,                                            coordinate_format="SAME_AS_INPUT")            # TODO update calculate statistics based on CP_SECTION            whereclause = f"{cp_section_fld} IS NULL OR {cp_section_fld} = ' ' OR {cp_section_fld} =''"            null_cps_mains = arcpy.management.SelectLayerByAttribute(in_layer_or_view=dist_mains_singlepart_lyr,                                            selection_type="NEW_SELECTION",                                            where_clause=whereclause,                                            invert_where_clause=None)            self.add_message(parameters, "Calculate Statistics CP_SECTION null...", gp_msg_no, status_no)            # summarize statistics to get collacation length            arcpy.analysis.Statistics(in_table=null_cps_mains,                                out_table=dist_mains_stats_table_cpsection_null,                                statistics_fields="SEGMENT_LENGTH SUM",                                case_field=route_id_fld,                                concatenation_separator="")            self.add_message(parameters, "Joining Field to get collocation length...", gp_msg_no, status_no)            arcpy.management.JoinField(in_data=null_cps_mains,                                in_field=route_id_fld,                                join_table=dist_mains_stats_table_cpsection_null,                                join_field=route_id_fld,                                fields=None,                                fm_option="NOT_USE_FM",                                field_mapping=None,                                index_join_fields="NO_INDEXES")            cps_mains = arcpy.management.SelectLayerByAttribute(in_layer_or_view=dist_mains_singlepart_lyr,                                            selection_type="NEW_SELECTION",                                            where_clause=whereclause,                                            invert_where_clause="INVERT")            self.add_message(parameters, "Calculate Statistics...", gp_msg_no, status_no)            # summarize statistics to get collacation length            arcpy.analysis.Statistics(in_table=cps_mains,                                out_table=dist_mains_stats_table_cpsection,                                statistics_fields="SEGMENT_LENGTH SUM",                                case_field=cp_section_fld,                                concatenation_separator="")            self.add_message(parameters, "Joining Field to get collocation length...", gp_msg_no, status_no)            arcpy.management.JoinField(in_data=cps_mains,                                in_field=cp_section_fld,                                join_table=dist_mains_stats_table_cpsection,                                join_field=cp_section_fld,                                fields=None,                                fm_option="NOT_USE_FM",                                field_mapping=None,                                index_join_fields="NO_INDEXES")            self.add_message(parameters, "Merging Statistics features...", gp_msg_no, status_no)            self.add_message(parameters, "Generate Near Table to get seperation length...", gp_msg_no, status_no)            # generate near table to get seperation distance            arcpy.analysis.GenerateNearTable(in_features=dist_mains_stats_fc,                                near_features=power_lines,                                out_table=dist_mains_to_powerline_neartable,                                search_radius=None,                                location="LOCATION",                                angle="ANGLE",                                closest="CLOSEST",                                closest_count=0,                                method="GEODESIC",                                distance_unit="Feet")            self.add_message(parameters, "Join Field to get seperation length...", gp_msg_no, status_no)            arcpy.management.JoinField(in_data=dist_mains_stats_fc,                                in_field="OBJECTID",                                join_table=dist_mains_to_powerline_neartable,                                join_field="IN_FID",                                fields=None,                                fm_option="NOT_USE_FM",                                field_mapping=None,                                index_join_fields="NO_INDEXES")            # ***************** add fields            self.add_message(parameters, "Add Fields to dist mains...", gp_msg_no, status_no)            # add fields            arcpy.management.AddFields(dist_mains_stats_fc, DIST_MAINS_FIELD_DESCRIPTION)            self.add_message(parameters, "Calculate Buffer distance field dist mains...", gp_msg_no, status_no)            arcpy.management.CalculateField(in_table=dist_mains_stats_fc,                                            field=buffer_ft_fld_name,                                            expression='str(!distance! + 5) + " FEET"',                                            expression_type="PYTHON3",                                            code_block="",                                            field_type="TEXT",                                            enforce_domains="NO_ENFORCE_DOMAINS")            self.add_message(parameters, "Done calculate Buffer distance field dist mains.", gp_msg_no, status_no)            # *****************            self.add_message(parameters, "Pairwise Buffer to intersected dist mains...", gp_msg_no, status_no)            # create buffers around the dist main intersect features to get power lines within the buffer,            # then calculate the crossing angle and get voltage            arcpy.analysis.PairwiseBuffer(in_features=dist_mains_stats_fc,                                    out_feature_class=dist_mains_singlepart_bufF_lyr,                                    buffer_distance_or_field=buffer_ft_fld_name,                                    dissolve_option="NONE",                                    dissolve_field=None,                                    method="GEODESIC",                                    max_deviation="0 Meters")            self.add_message(parameters, "Pairwise Intersect to power lines and dist mains bufffers...", gp_msg_no, status_no)            # intersect power lines with mains buffers            infeatures = [power_lines, dist_mains_singlepart_bufF_lyr]            arcpy.analysis.PairwiseIntersect(in_features=infeatures,                                    out_feature_class=power_lines_intersect_lyr,                                    join_attributes="ALL",                                    cluster_tolerance=None,                                    output_type="LINE")            self.add_message(parameters, "Multipart To Singlepart intersected power lines...", gp_msg_no, status_no)            # convert intersect features to single part            arcpy.management.MultipartToSinglepart(in_features=power_lines_intersect_lyr,                                            out_feature_class=power_lines_intersect_singlepart_lyr)            self.add_message(parameters, "Calculate Geometry Attributes intersected power lines..", gp_msg_no, status_no)            # calculate geometry attributes            arcpy.management.CalculateGeometryAttributes(in_features=power_lines_intersect_singlepart_lyr,                                                geometry_property="POWER_BEARING LINE_BEARING",                                                length_unit="FEET_US",                                                area_unit="",                                                coordinate_system=None,                                                coordinate_format="SAME_AS_INPUT")            self.add_message(parameters, "Feature Class To NumPy Array dist mains...", gp_msg_no, status_no)            # convert dist mains to numpy array            dist_mains_arr = arcpy.da.FeatureClassToNumPyArray(in_table=dist_mains_stats_fc,                                                    field_names =('MAINS_BEARING', 'OBJECTID',                                                                  route_id_fld, coating_type_fld,                                                                  "NEAR_DIST", "SUM_SEGMENT_LENGTH", "SUM_SEGMENT_LENGTH_1"),                                                    null_value=-9999)            self.add_message(parameters, "Feature Class To NumPy Array power lines..", gp_msg_no, status_no)            # convert power lines to numpy array            dist_mains_id_fld = 'FID_' +dist_mains_singlepart_buf_name            power_lines_arr = arcpy.da.FeatureClassToNumPyArray(in_table=power_lines_intersect_singlepart_lyr,                                                    field_names=('POWER_BEARING', voltage_fld, dist_mains_id_fld),                                                       null_value=-9999)            self.add_message(parameters, "Calculating attributes...", gp_msg_no, status_no)            results = {}            for row in dist_mains_arr:                objid = row['OBJECTID']                mains_bearing = row['MAINS_BEARING']                near_dist = row["NEAR_DIST"]                sep_dist_idx = self.get_seperation_dist_index(near_dist)                sum_length = row["SUM_SEGMENT_LENGTH"]                sum_length2 = row["SUM_SEGMENT_LENGTH_1"]                if sum_length == -9999:                    sum_length = sum_length2#                 sum_length = row["SUM_SEGMENT_LENGTH"]                collocation_index = self.get_collocation_index(sum_length)                coating_type = row[coating_type_fld]                coating_type_idx = self.calc_coating_cond_idx(coating_type)                power_rows = power_lines_arr[power_lines_arr[dist_mains_id_fld] == objid]                min_voltage = np.min(power_rows[voltage_fld])                max_voltage = np.max(power_rows[voltage_fld])                if min_voltage and min_voltage < 0:                    voltage = -999999                    cuurent_idx = 6                else:                    voltage = max_voltage                    cuurent_idx = self.get_current_index(voltage)                crossing_angle = 90                for prow in power_rows:                    power_bearing = prow['POWER_BEARING']                    angle = round(abs(power_bearing - mains_bearing), 2)                    if angle >= 270:                        a = 360 - angle                    elif angle >= 180 and angle < 270:                        a = angle - 180                    elif angle > 90 and angle < 180:                        a = 180 - angle                    else:                        a = angle                    if a < crossing_angle:                        crossing_angle = a                crossing_angle_idx = self.get_crossing_angle_index(crossing_angle)                # If coating type is “bare”, AC_Interference_Index = 0.                if coating_type == "BAR":                    ac_interference_idx = 0                    ac_corrosion = 0                else:                    ac_interference_idx = sep_dist_idx + cuurent_idx + coating_type_idx + collocation_index + crossing_angle_idx                    if ac_interference_idx <= x_min:                        ac_corrosion = y_min                    elif ac_interference_idx >= x_max:                        ac_corrosion = y_max                    else:                        ac_corrosion = xy_linear_relation[ac_interference_idx]                results[objid] = {Separation_Distance_fld : near_dist,                                  Separation_Distance_Index_fld : sep_dist_idx,                                  Voltage_fld : voltage,                                  Current_Index_fld : cuurent_idx,                                  'Coating_Type': coating_type,                                  Coating_Condition_Index_fld : coating_type_idx,                                  Collocation_Length_fld : sum_length,                                  Collocation_Length_Index_fld: collocation_index,                                  Crossing_Angle_fld : crossing_angle,                                  Crossing_Angle_Index_fld : crossing_angle_idx,                                  AC_Interference_Index_fld : ac_interference_idx,                                  AC_Interference_Corrosion_fld : ac_corrosion                                  }            # update corosion values in dist mains            self.add_message(parameters, "Updating dist mains...", gp_msg_no, status_no)            self.update_dist_mains(dist_mains_stats_fc, results)            self.add_message(parameters, "Creating output linear events table...", gp_msg_no, status_no)            arcpy.lr.LocateFeaturesAlongRoutes(in_features=dist_mains_stats_fc,                                            in_routes=dist_mains,                                            route_id_field=route_id_fld,                                            radius_or_tolerance="0 Meters",                                            out_table=output_table_path,                                            out_event_properties=route_id_fld +  "; LINE; FROM_MEASURE; TO_MEASURE",                                            route_locations="FIRST",                                            distance_field="DISTANCE",                                            zero_length_events="ZERO",                                            in_fields="FIELDS",                                            m_direction_offsetting="M_DIRECTON")            parameters[status_no].value = "Success"            self.add_message(parameters, "Completed!", gp_msg_no, status_no)        except Exception as e:            parameters[status_no].value = "Error"            self.add_message(parameters, str(e), gp_msg_no, status_no)            raise        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return