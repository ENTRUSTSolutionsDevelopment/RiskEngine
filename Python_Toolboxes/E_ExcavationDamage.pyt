# -*- coding: utf-8 -*-####################################################################################################################### Copyright Â© 2025 Entrust Solutions Group.# All Rights Reserved.# Threat Risk:#       Excavation Damage# Variable Type:#       Exposure, Mitigation, Resistance# Variable:#       Excavation, Excavation damage mitigation, Excavation damage resistance# Variable Description:#       Applicable to above grade pipe/components.#       Uses mpy degradation estimate considering moisture in air, temperature, and airborne chemicals.#       Above ground metallic only - need corrosiong input on rates# Units:#       events/mi-yr, %, %# Source(s):#       Distribution Mains#           URL: https://ene.maps.arcgis.com/home/item.html?id=cd0407318f46497ea53201ed9b19a884#       Divisions#             URL: https://services1.arcgis.com/Ebe2vzeJnfgD83DH/arcgis/rest/services/HexBins_District_Temp/FeatureServer/0#       damage summary reports#           URL: https://services1.arcgis.com/Ebe2vzeJnfgD83DH/arcgis/rest/services/Damages_Summary_Geocoded/FeatureServer/0#       Excavation records#           URL: https://services1.arcgis.com/Ebe2vzeJnfgD83DH/arcgis/rest/services/Excavation_Counts_Per_Division/FeatureServer/0# Field Name(s):#       N/A# Tier 1 Determination Method:#       Requirements documnet Location:#           I:\IN\0 Client\Avangrid\Projects\2309043.00 RGE_NYSEG DIMP Risk Model\2.0 Working Data\DS\#           \geoprocessing functional requirements drafts#           \Geoprocessing Requirements for Excavation Damage_v2.docx# Tier 1 Determination Method Source(s):#       N/A# Tier 2 Determination Method:#       N/A# Tier 2 Determination Method Source(s):#       N/A# Tier 3 Determination Method:#      N/A# Tier 3 Determination Method Source(s):#       N/A########################################################################################################################import arcpyimport numpy as np# online distribution mains feature class name,# this feature class will be created in the output GDB if it does not existDIST_MAINS_FC_NAME = "DistMains_Routes"# New fields to addAllExcavationEvents_fld = "AllExcavationEvents"TotalPipeLength_fld = "TotalPipeLength"ExcavationDamageTimespan_fld = "ExcavationDamageTimespan"Excavation_fld = "Excavation"ExcavationPracticeEventsPerYear_fld = "ExcavationPracticeEventsPerYear"ExcavationPracticeDamageYears_fld = "ExcavationPracticeDamageYears"ExcavationPracticeEvents_fld = "ExcavationPracticeEvents"PoD_ExcavationPractice_fld = "PoD_ExcavationPractice"PoF_ExcavationPractice_fld = "PoF_ExcavationPractice"LocatingPracticeEventsPerYear_fld = "LocatingPracticeEventsPerYear"LocatingPracticeDamageYears_fld = "LocatingPracticeDamageYears"LocatingPracticeEvents_fld = "LocatingPracticeEvents"PoD_LocatingPractice_fld = "PoD_LocatingPractice"PoF_LocatingPractice_fld = "PoF_LocatingPractice"OneCallNotificationPracticeEventsPerYear_fld = "OneCallNotificationPracticeEventsPerYear"OneCallNotificationPracticeDamageYears_fld = "OneCallNotificationPracticeDamageYears"OneCallNotificationPracticeEvents_fld = "OneCallNotificationPracticeEvents"PoD_OneCallNotificationPractice_fld = "PoD_OneCallNotificationPractice"PoF_OneCallNotificationPractice_fld = "PoF_OneCallNotificationPractice"MiscellaneousEventsPerYear_fld = "MiscellaneousEventsPerYear"MiscellaneousDamageYears_fld = "MiscellaneousDamageYears"MiscellaneousEvents_fld = "MiscellaneousEvents"PoD_Miscellaneous_fld = "PoD_Miscellaneous"PoF_Miscellaneous_fld = "PoF_Miscellaneous"PoF_ExcavationDamage_fld = "PoF_ExcavationDamage"DIST_MAINS_FIELD_DESCRIPTION = [[AllExcavationEvents_fld, "Double", AllExcavationEvents_fld, None],                [TotalPipeLength_fld, "Double", TotalPipeLength_fld, None],                [ExcavationDamageTimespan_fld, "Double", ExcavationDamageTimespan_fld, None],                [Excavation_fld, "Double", Excavation_fld, None],                [ExcavationPracticeEventsPerYear_fld, "Double", ExcavationPracticeEventsPerYear_fld, None],                [ExcavationPracticeDamageYears_fld, "Double", ExcavationPracticeDamageYears_fld, None],                [ExcavationPracticeEvents_fld, "Double", ExcavationPracticeEvents_fld, None],                [PoD_ExcavationPractice_fld, "Double", PoD_ExcavationPractice_fld, None],                [PoF_ExcavationPractice_fld, "Double", PoF_ExcavationPractice_fld, None],                [LocatingPracticeEventsPerYear_fld, "Double", LocatingPracticeEventsPerYear_fld, None],                [LocatingPracticeDamageYears_fld, "Double", LocatingPracticeDamageYears_fld, None],                [LocatingPracticeEvents_fld, "Double", LocatingPracticeEvents_fld, None],                [PoD_LocatingPractice_fld, "Double", PoD_LocatingPractice_fld, None],                [PoF_LocatingPractice_fld, "Double", PoF_LocatingPractice_fld, None],                [OneCallNotificationPracticeEventsPerYear_fld, "Double", OneCallNotificationPracticeEventsPerYear_fld, None],                [OneCallNotificationPracticeDamageYears_fld, "Double", OneCallNotificationPracticeDamageYears_fld, None],                [OneCallNotificationPracticeEvents_fld, "Double", OneCallNotificationPracticeEvents_fld, None],                [PoD_OneCallNotificationPractice_fld, "Double", PoD_OneCallNotificationPractice_fld, None],                [PoF_OneCallNotificationPractice_fld, "Double", PoF_OneCallNotificationPractice_fld, None],                [MiscellaneousEventsPerYear_fld, "Double", MiscellaneousEventsPerYear_fld, None],                [MiscellaneousDamageYears_fld, "Double", MiscellaneousDamageYears_fld, None],                [MiscellaneousEvents_fld, "Double", MiscellaneousEvents_fld, None],                [PoD_Miscellaneous_fld, "Double", PoD_Miscellaneous_fld, None],                [PoF_Miscellaneous_fld, "Double", PoF_Miscellaneous_fld, None],                [PoF_ExcavationDamage_fld, "Double",PoF_ExcavationDamage_fld, None]]class Toolbox:    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [E_ExcavationDamage]class E_ExcavationDamage:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "E_ExcavationDamage"        self.description = "E_ExcavationDamage"    def getParameterInfo(self):        """Define the tool parameters."""        params = []        # param 0        in_dist_mains = arcpy.Parameter(            displayName="Input Distribution Mains Features", name="in_dist_mains",            datatype="GPFeatureLayer", parameterType="Required",            direction="Input")#          # param 1#         dist_division_fld = arcpy.Parameter(#             displayName="Input Division Field",#             name="dist_division_fld",#             datatype="Field",#             parameterType="Required",#             direction="Input")#         dist_division_fld.parameterDependencies = [in_dist_mains.name]        # param 2        route_id_fld = arcpy.Parameter(            displayName="Input Dist Mains Unique ID Field Name",            name="route_id_fld",            datatype="GPString",            parameterType="Required",            direction="Input")         # param 3        in_divisions = arcpy.Parameter(            displayName="Input Divisions Features", name="in_divisions",            datatype="GPFeatureLayer", parameterType="Required",            direction="Input")         # param 4        div_division_fld = arcpy.Parameter(            displayName="Input Divisions Division Field",            name="div_division_fld",            datatype="Field",            parameterType="Required",            direction="Input")        div_division_fld.parameterDependencies = [in_divisions.name]          # param 5        in_damage_summary = arcpy.Parameter(            displayName="Input Damage Summary Rows", name="in_damage_summary",            datatype=["GPTableView", "GPFeatureLayer"], parameterType="Required",            direction="Input")##          # param 6#         damage_division_fld = arcpy.Parameter(#             displayName="Input Damage Summary Division Field",#             name="damage_division_fld",#             datatype="Field",#             parameterType="Required",#             direction="Input")#         damage_division_fld.parameterDependencies = [in_damage_summary.name]         # param 6        damage_year_fld = arcpy.Parameter(            displayName="Input Damage Year Field",            name="damage_year_fld",            datatype="Field",            parameterType="Required",            direction="Input")        damage_year_fld.parameterDependencies = [in_damage_summary.name]         # param 7        damage_rootcause_fld = arcpy.Parameter(            displayName="Input Damage Root Cause Field",            name="damage_rootcause_fld",            datatype="Field",            parameterType="Required",            direction="Input")        damage_rootcause_fld.parameterDependencies = [in_damage_summary.name]        # param 8        excav_practice_val = arcpy.Parameter(            displayName="Input Excavation Practice Value",            name="excav_practice_val",            datatype="GPString",            parameterType="Required",            direction="Input")        # param 9        location_practice_val = arcpy.Parameter(            displayName="Input Locating Practice Value",            name="location_practice_val",            datatype="GPString",            parameterType="Required",            direction="Input")        # param 10        onecall_practice_val = arcpy.Parameter(            displayName="Input OneCall Notification Practice Value",            name="onecall_practice_val",            datatype="GPString",            parameterType="Required",            direction="Input")        # param 11        miscellaneous_val = arcpy.Parameter(            displayName="Input Miscellaneous Value",            name="miscellaneous_val",            datatype="GPString",            parameterType="Required",            direction="Input")           # param 12        in_excav_rows = arcpy.Parameter(            displayName="Input Excavation Rows", name="in_excav_rows",            datatype=["GPTableView", "GPFeatureLayer"], parameterType="Required",            direction="Input")         # param 13        excav_division_fld = arcpy.Parameter(            displayName="Input Excavation Division Field",            name="excav_division_fld",            datatype="Field",            parameterType="Required",            direction="Input")        excav_division_fld.parameterDependencies = [in_excav_rows.name]         # param 14        excav_count_fld = arcpy.Parameter(            displayName="Input Excavation Count Field",            name="excav_count_fld",            datatype="Field",            parameterType="Required",            direction="Input")        excav_count_fld.parameterDependencies = [in_excav_rows.name]          # param 15        excav_years_fld = arcpy.Parameter(            displayName="Input Excavation Years Field",            name="excav_years_fld",            datatype="Field",            parameterType="Required",            direction="Input")        excav_years_fld.parameterDependencies = [in_excav_rows.name]        # param 16        out_gdb = arcpy.Parameter(            displayName="Output GDB",            name="out_gdb",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 17        out_excav_damage_table = arcpy.Parameter(            displayName="Output Excavation Damage Table",            name="out_excav_damage_table",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 18        gp_messages = arcpy.Parameter(            displayName="Geoprocessing Messages",            name="gp_messages",            datatype="GPString",            parameterType="Optional",            direction="Output")        # param 19        status = arcpy.Parameter(            displayName="Tool Status",            name="status",            datatype="GPString",            parameterType="Optional",            direction="Output")         # param 20        output_table = arcpy.Parameter(            displayName="Output Linear Events Table",            name="output_table",            datatype="GPTableView",            parameterType="Optional",            direction="Output")        # param 21        portal_ulr = arcpy.Parameter(            displayName="ArcGIS Portal URL",            name="portal_ulr",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 22        portal_username = arcpy.Parameter(            displayName="ArcGIS Portal User Name",            name="portal_username",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 23        portal_password = arcpy.Parameter(            displayName="ArcGIS Portal Password",            name="portal_password",            datatype="GPStringHidden",            parameterType="Optional",            direction="Input")        params = [in_dist_mains, # dist_division_fld,                        route_id_fld,                    in_divisions, div_division_fld,                    in_damage_summary, damage_year_fld, damage_rootcause_fld,                    excav_practice_val, location_practice_val, onecall_practice_val, miscellaneous_val,                    in_excav_rows, excav_division_fld, excav_count_fld, excav_years_fld,                    out_gdb, out_excav_damage_table,                    gp_messages, status,                    output_table, portal_ulr, portal_username, portal_password                    ]        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    def signin_portal(self, portal_url, username, password):        """            Login to the ArcGIS Portal to access input data sources            portal_url: ArcGIS Portal URL            username: User name            password: Password        """        if arcpy.GetSigninToken() is None:            try:                if username is not None and  password is not None:                    arcpy.SignInToPortal(portal_url, username, password)                else:                    arcpy.SignInToPortal(portal_url)                arcpy.AddMessage("ArcGIS Portal Login Successful.")            except Exception as e:                arcpy.AddError("ArcGIS Portal Login Failed!."                                "\n{}".format(arcpy.GetMessages(2)))                raise    def preprocess_distmains(self, infc, gdb, dist_mains_routes, unique_fld):        """            Creates online distribution mains features from input distribution mains features            infc: Input distribution mains features            gdb: Path of the geodatabase to save output online distribution mains features            dist_mains_routes: Name of the output online distribution mains feature class            unique_fld: Name of the GUID column to be added to output online distribution mains feature class        """        try:            dist_mains = os.path.join(gdb, "DistMains")            arcpy.AddMessage("Copy Features Dist Mains From Portal...")            from_meas_fld = "FROM_MEASURE"            to_meas_fld = "TO_MEASURE"            arcpy.management.CopyFeatures(in_features=infc,                                          out_feature_class=dist_mains,                                          config_keyword="",                                          spatial_grid_1=None,                                          spatial_grid_2=None,                                          spatial_grid_3=None)            field_list = arcpy.ListFields(dist_mains, from_meas_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{from_meas_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(dist_mains, from_meas_fld, "Double")                arcpy.AddMessage(f"Field '{from_meas_fld}' added successfully.")            arcpy.AddMessage("Calculate Geometry Attributes...")            arcpy.management.CalculateGeometryAttributes(in_features=dist_mains,                                                         geometry_property=to_meas_fld + " LENGTH_GEODESIC",                                                         length_unit="FEET_US",                                                         area_unit="",                                                         coordinate_system=None,                                                         coordinate_format="SAME_AS_INPUT")            field_list = arcpy.ListFields(dist_mains, unique_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{unique_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(dist_mains, unique_fld, "GUID")                arcpy.AddMessage(f"Field '{unique_fld}' added successfully.")            # Create an update cursor to calculate GUID values            with arcpy.da.UpdateCursor(dist_mains, [from_meas_fld, unique_fld]) as cursor:                for row in cursor:                    row[0] = 0                    # Generate a new GUID value                    guid_value = str(uuid.uuid4())                    # Update the row with the new GUID                    row[1] = guid_value                    cursor.updateRow(row)            arcpy.AddMessage(f"GUID values calculated and populated in the '{unique_fld}' field.")            arcpy.AddMessage("Creating route features...")            # create routes            arcpy.lr.CreateRoutes(                in_line_features=dist_mains,                route_id_field=unique_fld,                out_feature_class=dist_mains_routes,                measure_source="TWO_FIELDS",                from_measure_field=from_meas_fld,                to_measure_field=to_meas_fld,                coordinate_priority="UPPER_LEFT",                measure_factor=1,                measure_offset=0,                ignore_gaps="IGNORE",                build_index="INDEX"            )            arcpy.AddMessage("Join Field...")            arcpy.management.JoinField(                in_data=dist_mains_routes,                in_field=unique_fld,                join_table=dist_mains,                join_field=unique_fld,                fields=None,                fm_option="NOT_USE_FM",                field_mapping=None,                index_join_fields="NO_INDEXES"            )            field_list = arcpy.ListFields(dist_mains_routes, unique_fld+"_1")            if len(field_list) > 0:                arcpy.AddMessage("Delete Field...")                arcpy.management.DeleteField(dist_mains_routes,[unique_fld+"_1"])        except Exception as e:            raise    def add_message(self, parameters, msg, gp_msg_no, status_no):        try:            parameters[gp_msg_no].value = parameters[gp_msg_no].valueAsText + "\n " + msg            arcpy.AddMessage(msg)        except Exception as e:            parameters[gp_msg_no].value = parameters[gp_msg_no].valueAsText + "\n " + str(e)            parameters[status_no].value = "Error"            raise    def preprocess_divisions(self, in_divisions, out_gdb_name, divisions, div_division_fld):        try:            div_copy = os.path.join(out_gdb_name, "Divisions_CopyFeatures")            arcpy.management.CopyFeatures(in_features=in_divisions,                                          out_feature_class=div_copy,                                          config_keyword="",                                          spatial_grid_1=None,                                          spatial_grid_2=None,                                          spatial_grid_3=None)            arcpy.management.Dissolve(in_features=div_copy,                                    out_feature_class=divisions,                                    dissolve_field=div_division_fld)        except Exception as e:            raise    def preprocess_damage_summary(self, in_damage_summary, damage_summary):        try:            arcpy.management.CopyRows(in_rows=in_damage_summary,out_table=damage_summary)        except Exception as e:            raise    def preprocess_excavation_summary(self, in_excav_rows, excavation_summary):        try:            arcpy.management.CopyRows(in_rows=in_excav_rows,out_table=excavation_summary)        except Exception as e:            raise    def execute(self, parameters, messages):        """The source code of the tool."""        try:            arcpy.env.overwriteOutput = True            dist_mains = parameters[0].value#             dist_division_fld = parameters[1].valueAsText            route_id_fld = parameters[1].valueAsText            in_divisions = parameters[2].value            div_division_fld = parameters[3].valueAsText            in_damage_summary = parameters[4].value            damage_year_fld = parameters[5].valueAsText            damage_rootcause_fld = parameters[6].valueAsText            excav_practice_val = parameters[7].valueAsText            location_practice_val = parameters[8].valueAsText            onecall_practice_val = parameters[9].valueAsText            miscellaneous_val = parameters[10].valueAsText            in_excav_rows = parameters[11].value            excav_division_fld = parameters[12].valueAsText            excav_count_fld = parameters[13].valueAsText            excav_years_fld = parameters[14].valueAsText            out_gdb_name = parameters[15].valueAsText            out_excav_damage_table = parameters[16].valueAsText            gp_msg_no = 17            status_no = 18            parameters[19].value = os.path.join(out_gdb_name, out_excav_damage_table)            portal_ulr = parameters[20].value            portal_username = parameters[21].value            portal_password = parameters[22].value            linear_events_table = os.path.join(out_gdb_name, out_excav_damage_table)            linear_events_fc = os.path.join(out_gdb_name, out_excav_damage_table + "_FC")            dist_mains_routes =  os.path.join(out_gdb_name, DIST_MAINS_FC_NAME)            divisions =  os.path.join(out_gdb_name, "Divisions")            damage_summary =  os.path.join(out_gdb_name, "Damage_Summary")            excavation_summary =  os.path.join(out_gdb_name, "Excavation_Summary")            dist_mains_div_intersect =  os.path.join(out_gdb_name, "DistMains_Routes_Divisions_Intersect")            dist_mains_div_intersect_stat =  os.path.join(out_gdb_name, "DistMains_Routes_Divisions_Intersect_Stat")            damage_summary_div_intersect =  os.path.join(out_gdb_name, "Damage_Summary_Divisions_Intersect")            damage_summary_intersect_stat =  os.path.join(out_gdb_name, "Damage_Summary_Divisions_Intersect_Stat")            DAMAGE_SUMMARY_FIELD_DESCRIPTION = [["DamageYears", "Double", "DamageYears", None],                                    ["DamageEventsPerYear", "Double", "DamageEventsPerYear", None]]            parameters[gp_msg_no].value = "Starting..."            parameters[status_no].value = ""            # sign in to portal            self.signin_portal(portal_ulr, portal_username, portal_password)            # check in dist mains exist in the file geodatabase            self.add_message(parameters, "Checking Input Dist Mains...", gp_msg_no, status_no)            if not arcpy.Exists(dist_mains_routes):    #             # sign in to portal    #             self.signin_portal(portal_ulr, portal_username, portal_password)                self.preprocess_distmains(dist_mains, out_gdb_name, dist_mains_routes, route_id_fld)            self.add_message(parameters, "Checking Input Divisions...", gp_msg_no, status_no)            if not arcpy.Exists(divisions):                self.preprocess_divisions(in_divisions, out_gdb_name, divisions, div_division_fld)            self.add_message(parameters,"Checking Input Damage Summary...", gp_msg_no, status_no)            if not arcpy.Exists(damage_summary):                self.preprocess_damage_summary(in_damage_summary, damage_summary)            self.add_message(parameters, "Checking Input Excavation Summary...", gp_msg_no, status_no)            if not arcpy.Exists(excavation_summary):                self.preprocess_excavation_summary(in_excav_rows, excavation_summary)            # Intersect dist mains and divisions            self.add_message(parameters, "Pairwise Intersect Dist Mains and Divisions...", gp_msg_no, status_no)            inlayers = [dist_mains_routes, divisions]            arcpy.analysis.PairwiseIntersect(in_features=inlayers,                                                out_feature_class=dist_mains_div_intersect,                                                join_attributes="ALL",                                                cluster_tolerance=None,                                                output_type="LINE")            # calculate geometry attributes            self.add_message(parameters, "Calculate Geometry Attributes Dist Mains...", gp_msg_no, status_no)            arcpy.management.CalculateGeometryAttributes(in_features=dist_mains_div_intersect,                                                             geometry_property="Length_Miles LENGTH_GEODESIC",                                                             length_unit="MILES_US",                                                             area_unit="",                                                             coordinate_system=None,                                                             coordinate_format="SAME_AS_INPUT")            # summarize statistics to get segment length            self.add_message(parameters, "Statistics Dist Mains...", gp_msg_no, status_no)            arcpy.analysis.Statistics(in_table=dist_mains_div_intersect,                                out_table=dist_mains_div_intersect_stat,                                statistics_fields="Length_Miles SUM",                                case_field=div_division_fld,                                concatenation_separator="")            # Intersect damage summary and divisions            self.add_message(parameters, "Pairwise Intersect Damage Summary and Divisions...", gp_msg_no, status_no)            inlayers = [damage_summary, divisions]            arcpy.analysis.PairwiseIntersect(in_features=inlayers,                                                out_feature_class=damage_summary_div_intersect,                                                join_attributes="ALL")            # summarize statistics to get year wise stats            self.add_message(parameters,"Statistics Damage Summary...", gp_msg_no, status_no)            arcpy.analysis.Statistics(in_table=damage_summary_div_intersect,                                    out_table=damage_summary_intersect_stat,                                    statistics_fields=f"{damage_year_fld} MIN;{damage_year_fld} MAX",                                    case_field=f"{div_division_fld};{damage_rootcause_fld}",                                    concatenation_separator="")            # add fields to damage summary stats            self.add_message(parameters, "Add Fields Damage Summary...", gp_msg_no, status_no)            arcpy.management.AddFields(damage_summary_intersect_stat, DAMAGE_SUMMARY_FIELD_DESCRIPTION)            fields = ["DamageYears", "DamageEventsPerYear", div_division_fld,                        "MAX_" + damage_year_fld, "MIN_" + damage_year_fld, "FREQUENCY"]            self.add_message(parameters, "Calculate Fields Damage Summary...", gp_msg_no, status_no)            with arcpy.da.UpdateCursor(damage_summary_intersect_stat, fields) as cursor:                for row in cursor:                    years = row[3] - row[4] + 1                    row[0]= years                    row[1]= row[5] / years                    cursor.updateRow(row)            # join  damage stats and dist mains            self.add_message(parameters, "Join Field Damage Summary and Dist Mains...", gp_msg_no, status_no)            arcpy.management.JoinField(in_data=damage_summary_intersect_stat,                                    in_field=div_division_fld,                                    join_table=dist_mains_div_intersect_stat,                                    join_field=div_division_fld,                                    fields=None,                                    fm_option="NOT_USE_FM",                                    field_mapping=None,                                    index_join_fields="NO_INDEXES")             # join  damage stats and excavation stats            self.add_message(parameters, "Join Field Damage Summary and Excavation Summary...", gp_msg_no, status_no)            arcpy.management.JoinField(in_data=damage_summary_intersect_stat,                                    in_field=div_division_fld,                                    join_table=excavation_summary,                                    join_field=excav_division_fld,                                    fields=None,                                    fm_option="NOT_USE_FM",                                    field_mapping=None,                                    index_join_fields="NO_INDEXES")            # create damages np array            self.add_message(parameters, "Feature Class To NumPy Array Damage Summary...", gp_msg_no, status_no)            damage_arr = arcpy.da.FeatureClassToNumPyArray(in_table=damage_summary_intersect_stat,                                                field_names=(div_division_fld, excav_count_fld, excav_years_fld,                                                        "SUM_Length_Miles",                                                        damage_rootcause_fld, "FREQUENCY", "DamageYears", "DamageEventsPerYear"),                                                        null_value= 0)            # get unique divisions            divisions_unique = np.unique(damage_arr[div_division_fld])            # populate division attributes            self.add_message(parameters,"Calculating Damage Summary Attributes...", gp_msg_no, status_no)            division_values = {}            for division in divisions_unique:                rows = damage_arr[damage_arr[div_division_fld] == division]                AllExcavationEvents = 0                TotalPipeLength = 0                ExcavationDamageTimespan= 0                Excavation = 0                ExcavationPracticeEventsPerYear = 0                ExcavationPracticeDamageYears = 0                ExcavationPracticeEvents = 0                PoD_ExcavationPractice = 0                PoF_ExcavationPractice = 0                LocatingPracticeEventsPerYear = 0                LocatingPracticeDamageYears = 0                LocatingPracticeEvents = 0                PoD_LocatingPractice = 0                PoF_LocatingPractice = 0                OneCallNotificationPracticeEventsPerYear = 0                OneCallNotificationPracticeDamageYears = 0                OneCallNotificationPracticeEvents = 0                PoD_OneCallNotificationPractice = 0                PoF_OneCallNotificationPractice = 0                MiscellaneousEventsPerYear = 0                MiscellaneousDamageYears = 0                MiscellaneousEvents = 0                PoD_Miscellaneous = 0                PoF_Miscellaneous = 0                PoF_ExcavationDamage = 0                if len(rows) > 0:                    AllExcavationEvents = rows[excav_count_fld][0]                    TotalPipeLength =  rows["SUM_Length_Miles"][0]                    ExcavationDamageTimespan =  rows[excav_years_fld][0]                    if AllExcavationEvents  and AllExcavationEvents > 0:                        Excavation = AllExcavationEvents / (TotalPipeLength * ExcavationDamageTimespan)                    ExcavationPracticeRows = rows[rows[damage_rootcause_fld] == excav_practice_val]                    if len(ExcavationPracticeRows) > 0:                        ExcavationPracticeEventsPerYear = ExcavationPracticeRows["DamageEventsPerYear"][0]                        ExcavationPracticeDamageYears = ExcavationPracticeRows["DamageYears"][0]                        ExcavationPracticeEvents = ExcavationPracticeRows["FREQUENCY"][0]                        if AllExcavationEvents  and AllExcavationEvents > 0:                            PoD_ExcavationPractice = ExcavationPracticeEvents / AllExcavationEvents                        PoF_ExcavationPractice = PoD_ExcavationPractice * Excavation                    LocatingPracticeRows = rows[rows[damage_rootcause_fld] == location_practice_val]                    if len(LocatingPracticeRows) > 0:                        LocatingPracticeEventsPerYear = LocatingPracticeRows["DamageEventsPerYear"][0]                        LocatingPracticeDamageYears = LocatingPracticeRows["DamageYears"][0]                        LocatingPracticeEvents = LocatingPracticeRows["FREQUENCY"][0]                        if AllExcavationEvents  and AllExcavationEvents > 0:                            PoD_LocatingPractice = LocatingPracticeEvents / AllExcavationEvents                        PoF_LocatingPractice = PoD_LocatingPractice * Excavation                    OneCallNotificationPracticeRows = rows[rows[damage_rootcause_fld] == onecall_practice_val]                    if len(OneCallNotificationPracticeRows) > 0:                        OneCallNotificationPracticeEventsPerYear = OneCallNotificationPracticeRows["DamageEventsPerYear"][0]                        OneCallNotificationPracticeDamageYears = OneCallNotificationPracticeRows["DamageYears"][0]                        OneCallNotificationPracticeEvents = OneCallNotificationPracticeRows["FREQUENCY"][0]                        if AllExcavationEvents  and AllExcavationEvents > 0:                            PoD_OneCallNotificationPractice = OneCallNotificationPracticeEvents / AllExcavationEvents                        PoF_OneCallNotificationPractice = PoD_OneCallNotificationPractice * Excavation                    MiscellaneousRows = rows[rows[damage_rootcause_fld] == miscellaneous_val]                    if len(MiscellaneousRows) > 0:                        MiscellaneousEventsPerYear = MiscellaneousRows["DamageEventsPerYear"][0]                        MiscellaneousDamageYears = MiscellaneousRows["DamageYears"][0]                        MiscellaneousEvents = MiscellaneousRows["FREQUENCY"][0]                        if AllExcavationEvents  and AllExcavationEvents > 0:                            PoD_Miscellaneous = MiscellaneousEvents / AllExcavationEvents                        PoF_Miscellaneous = PoD_Miscellaneous * Excavation                    PoF_ExcavationDamage = PoF_ExcavationPractice + PoF_LocatingPractice + PoF_OneCallNotificationPractice + PoF_Miscellaneous                division_values[division] = {                                    AllExcavationEvents_fld: AllExcavationEvents,                                    TotalPipeLength_fld: TotalPipeLength,                                    ExcavationDamageTimespan_fld: ExcavationDamageTimespan,                                    Excavation_fld: Excavation,                                    ExcavationPracticeEventsPerYear_fld: ExcavationPracticeEventsPerYear,                                    ExcavationPracticeDamageYears_fld: ExcavationPracticeDamageYears,                                    ExcavationPracticeEvents_fld: ExcavationPracticeEvents,                                    PoD_ExcavationPractice_fld: PoD_ExcavationPractice,                                    PoF_ExcavationPractice_fld: PoF_ExcavationPractice,                                    LocatingPracticeEventsPerYear_fld: LocatingPracticeEventsPerYear,                                    LocatingPracticeDamageYears_fld: LocatingPracticeDamageYears,                                    LocatingPracticeEvents_fld: LocatingPracticeEvents,                                    PoD_LocatingPractice_fld: PoD_LocatingPractice,                                    PoF_LocatingPractice_fld: PoF_LocatingPractice,                                    OneCallNotificationPracticeEventsPerYear_fld: OneCallNotificationPracticeEventsPerYear,                                    OneCallNotificationPracticeDamageYears_fld: OneCallNotificationPracticeDamageYears,                                    OneCallNotificationPracticeEvents_fld: OneCallNotificationPracticeEvents,                                    PoD_OneCallNotificationPractice_fld: PoD_OneCallNotificationPractice,                                    PoF_OneCallNotificationPractice_fld: PoF_OneCallNotificationPractice,                                    MiscellaneousEventsPerYear_fld: MiscellaneousEventsPerYear,                                    MiscellaneousDamageYears_fld: MiscellaneousDamageYears,                                    MiscellaneousEvents_fld: MiscellaneousEvents,                                    PoD_Miscellaneous_fld: PoD_Miscellaneous,                                    PoF_Miscellaneous_fld: PoF_Miscellaneous,                                    PoF_ExcavationDamage_fld: PoF_ExcavationDamage                                    }            # add fields to dist mains            self.add_message(parameters, "Add Fields Dist Mains...", gp_msg_no, status_no)            arcpy.management.AddFields(dist_mains_div_intersect, DIST_MAINS_FIELD_DESCRIPTION)            # Update Dist mains            self.add_message(parameters,"Updating Dist Mains...", gp_msg_no, status_no)            fields =[div_division_fld, AllExcavationEvents_fld, TotalPipeLength_fld, ExcavationDamageTimespan_fld,  Excavation_fld,                        ExcavationPracticeEventsPerYear_fld, ExcavationPracticeDamageYears_fld, ExcavationPracticeEvents_fld,                        PoD_ExcavationPractice_fld, PoF_ExcavationPractice_fld,                        LocatingPracticeEventsPerYear_fld, LocatingPracticeDamageYears_fld, LocatingPracticeEvents_fld,                        PoD_LocatingPractice_fld, PoF_LocatingPractice_fld,                        OneCallNotificationPracticeEventsPerYear_fld, OneCallNotificationPracticeDamageYears_fld,                        OneCallNotificationPracticeEvents_fld, PoD_OneCallNotificationPractice_fld,                        PoF_OneCallNotificationPractice_fld,                        MiscellaneousEventsPerYear_fld, MiscellaneousDamageYears_fld, MiscellaneousEvents_fld,                        PoD_Miscellaneous_fld, PoF_Miscellaneous_fld,                       PoF_ExcavationDamage_fld]            with arcpy.da.UpdateCursor(dist_mains_div_intersect, fields) as cursor:                for row in cursor:                    division = row[0]                    if division and division.upper() in division_values:                        values = division_values[division]                        row[1] = values[AllExcavationEvents_fld]                        row[2] = values[TotalPipeLength_fld]                        row[3] = values[ExcavationDamageTimespan_fld]                        row[4] = values[Excavation_fld]                        row[5] = values[ExcavationPracticeEventsPerYear_fld]                        row[6] = values[ExcavationPracticeDamageYears_fld]                        row[7] = values[ExcavationPracticeEvents_fld]                        row[8] = values[PoD_ExcavationPractice_fld]                        row[9] = values[PoF_ExcavationPractice_fld]                        row[10] = values[LocatingPracticeEventsPerYear_fld]                        row[11] = values[LocatingPracticeDamageYears_fld]                        row[12] = values[LocatingPracticeEvents_fld]                        row[13] = values[PoD_LocatingPractice_fld]                        row[14] = values[PoF_LocatingPractice_fld]                        row[15] = values[OneCallNotificationPracticeEventsPerYear_fld]                        row[16] = values[OneCallNotificationPracticeDamageYears_fld]                        row[17] = values[OneCallNotificationPracticeEvents_fld]                        row[18] = values[PoD_OneCallNotificationPractice_fld]                        row[19] = values[PoF_OneCallNotificationPractice_fld]                        row[20] = values[MiscellaneousEventsPerYear_fld]                        row[21] = values[MiscellaneousDamageYears_fld]                        row[22] = values[MiscellaneousEvents_fld]                        row[23] = values[PoD_Miscellaneous_fld]                        row[24] = values[PoF_Miscellaneous_fld]                        row[25] = values[PoF_ExcavationDamage_fld]                    else:                        row[1] =  row[2] = row[3] = row[4] = row[5] = row[6] = row[7] = row[8] = row[9] = row[10] = 0                        row[11] = row[12] = row[13] = row[14] = row[15] = row[16] = row[17] = row[18] = row[19] = 0                        row[20] = row[21] = row[22] = row[23] = row[24] =  row[25] = 0                    cursor.updateRow(row)            self.add_message(parameters, "Creating output linear events table...", gp_msg_no, status_no)            arcpy.lr.LocateFeaturesAlongRoutes(in_features=dist_mains_div_intersect,                                            in_routes=dist_mains_routes,                                            route_id_field=route_id_fld,                                            radius_or_tolerance="0 Meters",                                            out_table=linear_events_table,                                            out_event_properties=route_id_fld +  "; LINE; FROM_MEASURE; TO_MEASURE",                                            route_locations="FIRST",                                            distance_field="DISTANCE",                                            zero_length_events="ZERO",                                            in_fields="FIELDS",                                            m_direction_offsetting="M_DIRECTON")            self.add_message(parameters, "Completed!", gp_msg_no, status_no)            parameters[status_no].value = "Success"        except Exception as e:            parameters[status_no].value = "Error"            self.add_message(parameters,  str(e), gp_msg_no, status_no)            raise        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return