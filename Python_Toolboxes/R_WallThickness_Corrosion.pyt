# -*- coding: utf-8 -*-####################################################################################################################### Copyright Â© 2025 Entrust Solutions Group.# All Rights Reserved.# Threat Risk:#       Corrosion# Variable Type:#       Resistance# Variable:#       Wall thickness# Variable Description:#       Wall thickness# Units:#       mils# Source:#       Distribution Mains#           URL: https://ene.maps.arcgis.com/home/item.html?id=cd0407318f46497ea53201ed9b19a884#       Coating Mitigation#           URL: N/A# Tier 1 Determination Method:#       if metallic, and a wall thickness measurement is available, and coating type is known, estimate effective wall thickness with this formula:#       effective wall thickness estimated =#           wall thickness measured#           - ((16 mpy * (1 - coating mitigation effectiveness))*years exposed without cp since wall thickness measurement)#           - ((1 mpy * (1 - coating mitigation effectiveness))*years exposed with cp since wall thickness measurement)##       effective wall thickness minimum = 0.10 * wall thickness measured##       result = MAX(effective wall thickness estimated, effective wall thickness minimum)# Tier 1 Determination Method Source(s):#         wall thickness measurements, coating type# Tier 2 Determination Method:#       if metallic, and installation date is available, and nominal wall thickness is available, and coating type is known,  estimate effective wall thickness with this formula:#       effective wall thickness estimated =#       wall thickness installed#       - ((16 mpy * (1 - coating mitigation effectiveness))*years exposed without cp since wall thickness measurement)#       - ((1 mpy * (1 - coating mitigation effectiveness))*years exposed with cp since wall thickness measurement)#       effective wall thickness minimum = 0.10 * wall thickness installed#       result = MAX(effective wall thickness estimated, effective wall thickness minimum)# Tier 2 Determination Method Source(s):#       installation date, coating type# Tier 3 Determination Method:#       if metallic, and nominal diameter is known, estimate effective wall thickness with this formula:#       effective wall thickness estimated =#       assumed wall thickness on install#       - ((16 mpy * (1 - coating mitigation effectiveness))*years exposed without cp since wall thickness measurement)#       - ((1 mpy * (1 - coating mitigation effectiveness))*years exposed with cp since wall thickness measurement)#       effective wall thickness minimum = 0.10 * assumed wall thickness on install#       result = MAX(effective wall thickness estimated, effective wall thickness minimum)# Tier 3 Determination Method Source(s):#       nominal diameter#######################################################################################################################import arcpyfrom datetime import date,datetimeimport numpy as npimport math# online distribution mains feature class name,# this feature class will be created in the output GDB if it does not existDIST_MAINS_FC_NAME = "DistMains_Routes"# New fields to addCoatingMitigationEffectiveness_fld = "CoatingMitigationEffectiveness"CPInstallDate_fld = "CPInstallDate"YearsExposedWithoutCP_fld = "YearsExposedWithoutCP"YearsExposedWithCP_fld = "YearsExposedWithCP"WallThicknessMils_fld = "WallThicknessMils"MinWallThickness_fld = "MinWallThickness"AssumedWallThickness_fld = "AssumedWallThickness"WallThicknessEffectiveness_fld = "WallThicknessEffectiveness"DIST_MAINS_FIELD_DESCRIPTION = [                                [CoatingMitigationEffectiveness_fld, "Double", CoatingMitigationEffectiveness_fld, None],                                [CPInstallDate_fld, "Date", CPInstallDate_fld, None],                                [YearsExposedWithoutCP_fld, "Double", YearsExposedWithoutCP_fld, None],                                [YearsExposedWithCP_fld, "Double", YearsExposedWithCP_fld, None],                                [WallThicknessMils_fld, "Double", WallThicknessMils_fld, None],                                [MinWallThickness_fld, "Double", MinWallThickness_fld, None],                                [AssumedWallThickness_fld, "Double", AssumedWallThickness_fld, None],                                [WallThicknessEffectiveness_fld, "Double", WallThicknessEffectiveness_fld, None]                               ]class Toolbox:    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "R_WallThickness_Corrosion"        self.alias = "R_WallThickness_Corrosion"        # List of tool classes associated with this toolbox        self.tools = [R_WallThickness_Corrosion]class R_WallThickness_Corrosion:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "R_WallThickness_Corrosion"        self.description = "R_WallThickness_Corrosion"    def getParameterInfo(self):        """Define the tool parameters."""         # param 0        in_dist_mains = arcpy.Parameter(            displayName="Input Distribution Mains Features", name="in_dist_mains",            datatype="GPFeatureLayer", parameterType="Required",            direction="Input")        # param 1        material_fld = arcpy.Parameter(            displayName="Input Material Type Field",            name="material_fld",            datatype="Field",            parameterType="Required",            direction="Input")        material_fld.parameterDependencies = [in_dist_mains.name]        # param 2        plastic_material_val = arcpy.Parameter(            displayName="Input Plastic Material Type Value",            name="plastic_material_val",            datatype="GPLong",            parameterType="Required",            direction="Input")        # param 3        route_id_fld = arcpy.Parameter(            displayName="Input Dist Mains Unique ID Field Name",            name="route_id_fld",            datatype="GPString",            parameterType="Required",            direction="Input")        # param 4        coating_type_fld = arcpy.Parameter(            displayName="Input Coating Type Field",            name="coating_type_fld",            datatype="Field",            parameterType="Required",            direction="Input")        coating_type_fld.parameterDependencies = [in_dist_mains.name]        # param 5        pipe_install_date_fld = arcpy.Parameter(            displayName="Input Pipe Installation Date Field",            name="pipe_install_date_fld",            datatype="Field",            parameterType="Required",            direction="Input")        pipe_install_date_fld.parameterDependencies = [in_dist_mains.name]        # param 6        wall_thickness_fld = arcpy.Parameter(            displayName="Input Wall Thickness Field",            name="wall_thickness_fld",            datatype="Field",            parameterType="Optional",            direction="Input")        wall_thickness_fld.parameterDependencies = [in_dist_mains.name]        # param 7        min_wall_thickness_value = arcpy.Parameter(            displayName="Input Minimum Wall Thickness Value (%)",            name="min_wall_thickness_value",            datatype="GPDouble",            parameterType="Optional",            direction="Input")        # param 8        cp_install_date = arcpy.Parameter(            displayName="Input CP Installation Date",            name="cp_install_date",            datatype="GPDate",            parameterType="Required",            direction="Input")        # param 9        nom_diameter_fld = arcpy.Parameter(            displayName="Input Nominal Diameter Field",            name="nom_diameter_fld",            datatype="Field",            parameterType="Optional",            direction="Input")        nom_diameter_fld.parameterDependencies = [in_dist_mains.name]        # param 10        assumed_wall_thickness_value = arcpy.Parameter(            displayName="Input Assumed Wall Thickness On Install (Inches)",            name="assumed_wall_thickness_value",            datatype="GPDouble",            parameterType="Optional",            direction="Input")        params = [in_dist_mains, material_fld, plastic_material_val, route_id_fld, coating_type_fld,                    pipe_install_date_fld, wall_thickness_fld, min_wall_thickness_value,                    cp_install_date,  nom_diameter_fld, assumed_wall_thickness_value]        # param 11        in_coating_mit_rows = arcpy.Parameter(            displayName="Input Coating Mitigation Features", name="in_coating_mit_rows",            datatype=["GPTableView","GPFeatureLayer" ], parameterType="Required",            direction="Input")        # param 12        coating_mit_fld = arcpy.Parameter(            displayName="Input Coating Mitigation Field",            name="coating_mit_fld",            datatype="Field",            parameterType="Required",            direction="Input")        coating_mit_fld.parameterDependencies = [in_coating_mit_rows.name]        params += [in_coating_mit_rows, coating_mit_fld]         # param 13        out_gdb = arcpy.Parameter(            displayName="Output GDB",            name="out_gdb",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 14        out_wall_thickness_table = arcpy.Parameter(            displayName="Output Wall Thickness Effectiveness Table",            name="out_wall_thickness_table",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 15        gp_messages = arcpy.Parameter(            displayName="Geoprocessing Messages",            name="gp_messages",            datatype="GPString",            parameterType="Optional",            direction="Output")        # param 16        status = arcpy.Parameter(            displayName="Tool Status",            name="status",            datatype="GPString",            parameterType="Optional",            direction="Output")         # param 17        output_table = arcpy.Parameter(            displayName="Output Linear Events Table",            name="output_table",            datatype="GPTableView",            parameterType="Optional",            direction="Output")        # param 18        portal_ulr = arcpy.Parameter(            displayName="ArcGIS Portal URL",            name="portal_ulr",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 19        portal_username = arcpy.Parameter(            displayName="ArcGIS Portal User Name",            name="portal_username",            datatype="GPString",            parameterType="Optional",            direction="Input")        # param 20        portal_password = arcpy.Parameter(            displayName="ArcGIS Portal Password",            name="portal_password",            datatype="GPStringHidden",            parameterType="Optional",            direction="Input")        params += [out_gdb, out_wall_thickness_table, gp_messages, status, output_table,                            portal_ulr, portal_username, portal_password]        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    def signin_portal(self, portal_url, username, password):        """            Login to the ArcGIS Portal to access input data sources            portal_url: ArcGIS Portal URL            username: User name            password: Password        """        if arcpy.GetSigninToken() is None:            try:                if username is not None and  password is not None:                    arcpy.SignInToPortal(portal_url, username, password)                else:                    arcpy.SignInToPortal(portal_url)                arcpy.AddMessage("ArcGIS Portal Login Successful.")            except Exception as e:                arcpy.AddError("ArcGIS Portal Login Failed!."                                "\n{}".format(arcpy.GetMessages(2)))                raise    def preprocess_distmains(self, infc, gdb, dist_mains_routes, unique_fld):        """            Creates online distribution mains features from input distribution mains features            infc: Input distribution mains features            gdb: Path of the geodatabase to save output online distribution mains features            dist_mains_routes: Name of the output online distribution mains feature class            unique_fld: Name of the GUID column to be added to output online distribution mains feature class        """        try:            dist_mains = os.path.join(gdb, "DistMains")            arcpy.AddMessage("Copy Features Dist Mains From Portal...")            from_meas_fld = "FROM_MEASURE"            to_meas_fld = "TO_MEASURE"            arcpy.management.CopyFeatures(in_features=infc,                                          out_feature_class=dist_mains,                                          config_keyword="",                                          spatial_grid_1=None,                                          spatial_grid_2=None,                                          spatial_grid_3=None)            field_list = arcpy.ListFields(dist_mains, from_meas_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{from_meas_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(dist_mains, from_meas_fld, "Double")                arcpy.AddMessage(f"Field '{from_meas_fld}' added successfully.")            arcpy.AddMessage("Calculate Geometry Attributes...")            arcpy.management.CalculateGeometryAttributes(in_features=dist_mains,                                                         geometry_property=to_meas_fld + " LENGTH_GEODESIC",                                                         length_unit="FEET_US",                                                         area_unit="",                                                         coordinate_system=None,                                                         coordinate_format="SAME_AS_INPUT")            field_list = arcpy.ListFields(dist_mains, unique_fld)            if len(field_list) > 0:                arcpy.AddMessage(f"Field '{unique_fld}' already exists.")            else:                # Add a new GUID field                arcpy.AddField_management(dist_mains, unique_fld, "GUID")                arcpy.AddMessage(f"Field '{unique_fld}' added successfully.")            # Create an update cursor to calculate GUID values            with arcpy.da.UpdateCursor(dist_mains, [from_meas_fld, unique_fld]) as cursor:                for row in cursor:                    row[0] = 0                    # Generate a new GUID value                    guid_value = str(uuid.uuid4())                    # Update the row with the new GUID                    row[1] = guid_value                    cursor.updateRow(row)            arcpy.AddMessage(f"GUID values calculated and populated in the '{unique_fld}' field.")            arcpy.AddMessage("Creating route features...")            # create routes            arcpy.lr.CreateRoutes(                in_line_features=dist_mains,                route_id_field=unique_fld,                out_feature_class=dist_mains_routes,                measure_source="TWO_FIELDS",                from_measure_field=from_meas_fld,                to_measure_field=to_meas_fld,                coordinate_priority="UPPER_LEFT",                measure_factor=1,                measure_offset=0,                ignore_gaps="IGNORE",                build_index="INDEX"            )            arcpy.AddMessage("Join Field...")            arcpy.management.JoinField(                in_data=dist_mains_routes,                in_field=unique_fld,                join_table=dist_mains,                join_field=unique_fld,                fields=None,                fm_option="NOT_USE_FM",                field_mapping=None,                index_join_fields="NO_INDEXES"            )            field_list = arcpy.ListFields(dist_mains_routes, unique_fld+"_1")            if len(field_list) > 0:                arcpy.AddMessage("Delete Field...")                arcpy.management.DeleteField(dist_mains_routes,[unique_fld+"_1"])        except Exception as e:            raise    def add_message(self, parameters, msg, gp_msg_no, status_no):        try:            parameters[gp_msg_no].value = parameters[gp_msg_no].valueAsText + "\n " + msg            arcpy.AddMessage(msg)        except Exception as e:            parameters[gp_msg_no].value = parameters[gp_msg_no].valueAsText + "\n " + str(e)            parameters[status_no].value = "Error"            raise    def execute(self, parameters, messages):        """The source code of the tool."""        try:            arcpy.env.overwriteOutput = True            dist_mains = parameters[0].value            material_fld = parameters[1].valueAsText            plastic_material_val = int(parameters[2].value)            route_id_fld = parameters[3].valueAsText            coating_type_fld = parameters[4].valueAsText            pipe_install_date_fld = parameters[5].valueAsText            wall_thickness_fld = parameters[6].valueAsText            min_wall_thickness_value = 0            if parameters[7].value:                min_wall_thickness_value = float(parameters[7].value)             # convert from percent            min_wall_thickness_value = min_wall_thickness_value / 100            cp_install_date = parameters[8].value            nom_diameter_fld = ""            if parameters[9].value:                nom_diameter_fld = parameters[9].valueAsText            assumed_wall_thickness_value = 0            if parameters[10].value:                assumed_wall_thickness_value = float(parameters[10].value)            in_coating_mit_rows = parameters[11].value            coating_mit_fld = parameters[12].valueAsText            out_gdb_name = parameters[13].valueAsText            out_wallthickness_table = parameters[14].valueAsText            gp_msg_no = 15            status_no = 16            parameters[17].value = os.path.join(out_gdb_name, out_wallthickness_table)            portal_ulr = parameters[18].value            portal_username = parameters[19].value            portal_password = parameters[20].value            linear_events_table = os.path.join(out_gdb_name, out_wallthickness_table)            linear_events_fc = os.path.join(out_gdb_name, out_wallthickness_table + "_FC")            dist_mains_routes =  os.path.join(out_gdb_name, DIST_MAINS_FC_NAME)            parameters[gp_msg_no].value = "Starting..."            parameters[status_no].value = ""            # sign in to portal            self.signin_portal(portal_ulr, portal_username, portal_password)            # check in dist mains exist in the file geodatabase            self.add_message(parameters, "Checking Input Dist Mains...", gp_msg_no, status_no)            if not arcpy.Exists(dist_mains_routes):                self.preprocess_distmains(dist_mains, out_gdb_name, dist_mains_routes, route_id_fld)            # select non plastic distribution main            self.add_message(parameters, "Select Layer By Attribute Metallic Mains...", gp_msg_no, status_no)            dist_metallic = arcpy.management.SelectLayerByAttribute(in_layer_or_view=dist_mains_routes,                                    selection_type="NEW_SELECTION",                                    where_clause=f"{material_fld} NOT IN ({plastic_material_val})",                                    invert_where_clause=None)            self.add_message(parameters, "Copy Features Metallic Mains...", gp_msg_no, status_no)            arcpy.management.CopyFeatures(in_features=dist_metallic,                                            out_feature_class=linear_events_fc,                                            config_keyword="",                                            spatial_grid_1=None,                                            spatial_grid_2=None,                                            spatial_grid_3=None)             # add fields to dist mains            self.add_message(parameters, "Add Fields Dist Mains...", gp_msg_no, status_no)            arcpy.management.AddFields(linear_events_fc, DIST_MAINS_FIELD_DESCRIPTION)            self.add_message(parameters, "Feature Class To NumPy Array Coating Mitigation...", gp_msg_no, status_no)            coating_mit_arr = arcpy.da.FeatureClassToNumPyArray(in_table=in_coating_mit_rows,                                                    field_names=(route_id_fld, coating_mit_fld),                                                       null_value=-9999)            whereclause = f"{pipe_install_date_fld} IS NOT NULL"            sqlclause = (None, f'ORDER BY {pipe_install_date_fld}')            old_install_date = None            with arcpy.da.SearchCursor(linear_events_fc, [pipe_install_date_fld],                                    where_clause = whereclause, sql_clause=sqlclause) as cursor:                for row in cursor:                    old_install_date = row[0]                    break            # Update Dist mains            self.add_message(parameters, "Updating Dist Mains...", gp_msg_no, status_no)            # check if nominal diameter field and assumed wall_thickness_effectiveness value            # fields length = 11 if nom_diameter_fld provided else 10            if nom_diameter_fld and assumed_wall_thickness_value > 0:                nom_diameter_fld = parameters[8].valueAsText                flds = [route_id_fld, pipe_install_date_fld,                    wall_thickness_fld, coating_type_fld,                    CoatingMitigationEffectiveness_fld, CPInstallDate_fld,                    YearsExposedWithoutCP_fld,  YearsExposedWithCP_fld,                    AssumedWallThickness_fld, WallThicknessEffectiveness_fld, WallThicknessMils_fld,                    MinWallThickness_fld, nom_diameter_fld]            else:                flds = [route_id_fld, pipe_install_date_fld,                        wall_thickness_fld, coating_type_fld,                        CoatingMitigationEffectiveness_fld, CPInstallDate_fld,                        YearsExposedWithoutCP_fld,  YearsExposedWithCP_fld,                        AssumedWallThickness_fld, WallThicknessEffectiveness_fld,                        WallThicknessMils_fld, MinWallThickness_fld]            today = date.today()            with arcpy.da.UpdateCursor(linear_events_fc, flds) as cursor:                for row in cursor:                    route_id = row[0]                    install_date = row[1]                    wall_thickness = row[2]                    coating_type = row[3]                    cp_date = cp_install_date.date()                    years_exposed_without_cp = -9999                    years_exposed_with_cp =  -9999                    if install_date:                        install_date = install_date.date()                        if install_date < cp_date:                            years_exposed_without_cp = (cp_date - install_date).days                            years_exposed_without_cp = round(years_exposed_without_cp / 365.25, 2)                        else:                            years_exposed_without_cp = 0                        years_exposed_with_cp = (today - cp_date).days                        years_exposed_with_cp = round(years_exposed_with_cp / 365.25, 2)                    coating_rows = coating_mit_arr[coating_mit_arr[route_id_fld] == route_id]                    coating_mit_effectiveness = 0                    if len(coating_rows) >  0:                        coating_mit_effectiveness = coating_rows[coating_mit_fld][0]                    nominal_diameter = 0                    if len(flds) > 12:                        nominal_diameter = row[12]                    wall_thickness_mils = 0                    if install_date and wall_thickness and coating_type:                        # convert wall thickness to mils                        wall_thickness_mils =  wall_thickness * 1000                        min_effective_wall_thickness = min_wall_thickness_value * wall_thickness_mils                        if years_exposed_without_cp > 0:                            wall_thickness_effectiveness = wall_thickness_mils - ((16 * (1-coating_mit_effectiveness)) / years_exposed_without_cp) - ((1 * (1-coating_mit_effectiveness)) / years_exposed_with_cp)                        else:                            wall_thickness_effectiveness = wall_thickness_mils - ((1 * (1-coating_mit_effectiveness)) / years_exposed_with_cp)                    elif nominal_diameter > 0 and assumed_wall_thickness_value > 0:                        # convert wall thickness to mils                        wall_thickness_mils = assumed_wall_thickness_value * 1000                        min_effective_wall_thickness = min_wall_thickness_value * wall_thickness_mils                        if years_exposed_without_cp > 0:                            wall_thickness_effectiveness = wall_thickness_mils - ((16 * (1-coating_mit_effectiveness))/years_exposed_without_cp) - ((1 * (1-coating_mit_effectiveness))/years_exposed_with_cp)                        else:                            wall_thickness_effectiveness = wall_thickness_mils - ((1 * (1-coating_mit_effectiveness))/years_exposed_with_cp)                    else:                        wall_thickness_effectiveness = 0#                     result = MAX(wall_thickness_effectiveness, min_wall_thickness_value)                    row[4] = coating_mit_effectiveness                    row[5] = cp_date                    row[6] = years_exposed_without_cp                    row[7] = years_exposed_with_cp                    if assumed_wall_thickness_value > 0:                        row[8] = assumed_wall_thickness_value                    row[9] = max(float(wall_thickness_effectiveness), float(min_wall_thickness_value)) #wall_thickness_effectiveness                    row[10] = wall_thickness_mils                    row[11] = min_wall_thickness_value                    cursor.updateRow(row)            self.add_message(parameters, "Creating output linear events table...", gp_msg_no, status_no)            arcpy.conversion.ExportTable(in_table=linear_events_fc,out_table=linear_events_table)            parameters[status_no].value = "Success"            self.add_message(parameters, "Completed!", gp_msg_no, status_no)        except Exception as e:            parameters[status_no].value = "Error"            self.add_message(parameters, str(e), gp_msg_no, status_no)            raise        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return